# lng_gds.rb

# ATTENTION: this file is generated

module LDLgeneratedLanguage

  class Language_gds_03_data
    def self.config
      @@config ||= {}
    end
  end

  class Gds
    require 'treetop'

    class SyntaxError < ::StandardError
    end

    def self.parse( s, config = {} )
      ::LDLgeneratedLanguage::Language_gds_03_data.config.replace( { allow_env: false, context: nil }.merge( config ) )

      @parserClass ||= begin
        Treetop.load_from_string GrammarDef
        instance_eval( 'Language_gds_03Parser' )
      end
      parser = @parserClass.new

      parseTree = parser.parse( s + "\n" )

      unless parseTree
        lineOfFailure   = parser.failure_line
        columnOfFailure = parser.failure_column

        s = "GDS: Error happend, while parsing the definition: line #{lineOfFailure}, column #{columnOfFailure}" + "\n"
        s += parser.failure_reason + "\n"  if parser.failure_reason
        s += "--->" + "\n"
        s += parser.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + "\n"
        s += ' '*((parser.failure_column) -1) + '^' + "\n"
        s += "<---" + "\n"

        raise SyntaxError, s
      end

      parseTree.ast
    end

    GrammarDef = "grammar Language_gds_03\n\n  rule top\n    &{ |s| @indentationLevels = []; true }\n    defs ''\n    {\n      def ast\n        eval 'class ::LDLgeneratedLanguage::Language_gds_03_data; def self.globalvars; @@globalvars ||= {}; end; end'\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars.clear\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata] ||= {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars] ||= {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences] ||= {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] ||= []\n        defs.ast\n      end\n    }\n  end\n\n  rule defs\n    wscommnl* predefs wscommnl* defs2 \n    {\n      def ast\n        dummy = predefs.ast\n        defs2.ast\n      end\n    }\n  end\n\n  rule predefs\n    predef* \n    {\n      def ast\n        elements.each { |e| e.ast }\n      end\n    }\n  end\n\n  rule predef\n    wscommnl2 '@schema' wscommnl2 schemaname wscommnl2 '(' wscommnl2 schema_fieldlist wscommnl2 ')'  \n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast] = schema_fieldlist.ast\n      end\n    }\n    /\n    wscommnl2 '$' varname wscommnl2 '=' wscommnl2 vardef_rvalue  \n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars][varname.ast] = vardef_rvalue.ast\n      end\n    }\n  end\n\n  rule schemaname\n    identifier '' \n    {\n      def ast\n        identifier.ast\n      end\n    }\n  end\n\n  rule varname\n    identifier ''\n    {\n      def ast\n        identifier.ast\n      end\n    }\n  end\n\n  rule vardef_rvalue\n    valuedef_ind ''\n    {\n      def ast\n        valuedef_ind.ast\n      end\n    }\n  end\n\n  rule schema_fieldlist\n    schemafield ws ',' ws schema_fieldlist \n    {\n      def ast\n        r = []\n        r << schemafield.ast\n        r2 = schema_fieldlist.ast\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    schemafield '' \n    {\n      def ast\n        r = []\n        r << schemafield.ast\n        r\n      end\n    }\n  end\n\n  rule schemafield\n    identifier '' \n    {\n      def ast\n        identifier.ast\n      end\n    }\n  end\n\n  rule defs2\n    wscommnl2 ruby_standard_def wscommnl2\n    {\n      def ast\n        ruby_standard_def.ast\n      end\n    }\n    /\n    wscommnl* special_indented_def wscommnl2\n    {\n      def ast\n        special_indented_def.ast\n      end\n    }\n  end\n\n  rule ruby_standard_def\n    hashdef ''\n    {\n      def ast\n        hashdef.ast\n      end\n    }\n    /\n    arraydef ''\n    {\n      def ast\n        arraydef.ast\n      end\n    }\n  end\n\n  rule special_indented_def\n    arraydef_ind ''\n    {\n      def ast\n        arraydef_ind.ast\n      end\n    }\n    /\n    hashdef_ind ''\n    {\n      def ast\n        hashdef_ind.ast\n      end\n    }\n  end\n\n  rule hashdef\n    wscommnl2 '{' wscommnl2 hashsubdefs wscommnl2 '}' \n    {\n      def ast\n        hashsubdefs.ast\n      end\n    }\n  end\n\n  rule arraydef\n    wscommnl2 '[' wscommnl2 arraysubdefs wscommnl2 ']' \n    {\n      def ast\n        arraysubdefs.ast\n      end\n    }\n  end\n\n  rule hashsubdefs\n    hashsubdef wscommnl2 morehashsubdefs wscommnl2 ','? \n    {\n      def ast\n        r = {}\n        r.merge!( hashsubdef.ast )\n        r.merge!( morehashsubdefs.ast )\n        r\n      end\n    }\n    /\n    ''\n    {\n      def ast\n        {}\n      end\n    }\n  end\n\n  rule morehashsubdefs\n    morehashsubdef*\n    {\n      def ast\n        r = {}\n        elements.each { |e| r.merge!( e.ast ) }\n        r\n      end\n    }\n  end\n\n  rule morehashsubdef\n    wscommnl2 ',' wscommnl2 hashsubdef\n    {\n      def ast\n        hashsubdef.ast\n      end\n    }\n  end\n\n  rule hashsubdef\n    keyvaluedef ''\n    {\n      def ast\n        keyvaluedef.ast\n      end\n    }\n    /\n    keydef ':' wscommnl2 hashdef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashdef.ast ] )\n        r\n      end\n    }\n    /\n    wscommnl2 ':' keydef wscommnl2 '=>' wscommnl2 hashdef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashdef.ast ] )\n        r\n      end\n    }\n    /\n    keydef ':' wscommnl2 arraydef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, arraydef.ast ] )\n        r\n      end\n    }\n    /\n    wscommnl2 ':' keydef wscommnl2 '=>' wscommnl2 arraydef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, arraydef.ast ] )\n        r\n      end\n    }\n  end\n\n  rule arraysubdefs\n    arraysubdef wscommnl2 morearraysubdefs wscommnl2 ','? \n    {\n      def ast\n        r = []\n        r << arraysubdef.ast\n        r2 = morearraysubdefs.ast\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    '' \n    {\n      def ast\n        r = []\n        r\n      end\n    }\n  end\n\n  rule morearraysubdefs\n    morearraysubdef* \n    {\n      def ast\n        r = []\n        elements.each do |e|\n          r << e.ast\n        end\n        r\n      end\n    }\n  end\n\n  rule morearraysubdef\n    wscommnl2 ',' wscommnl2 arraysubdef\n    {\n      def ast\n        arraysubdef.ast\n      end\n    }\n  end\n\n  rule arraysubdef\n    valuedef ''\n    {\n      def ast\n        valuedef.ast\n      end\n    }\n    /\n    arraydef ''\n    {\n      def ast\n        arraydef.ast\n      end\n    }\n    /\n    hashdef ''\n    {\n      def ast\n        hashdef.ast\n      end\n    }\n    /\n    hashsubdef ''\n    {\n      def ast\n        hashsubdef.ast\n      end\n    }\n  end\n\n  rule hashdef_ind\n    indentation bc_0_l:(bc_0*) ws ': ' ws refdef_tl:refdef? ws keyvaluedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    hashsubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = keyvaluedefs_ind.ast  unless refdef_tl.empty?\n        r.merge!( keyvaluedefs_ind.ast )\n        r.merge!( hashsubdefs_ind.ast )\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws ': ' ws keydef ws refdef_tl:refdef? wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; @indentationLevels << (2+level); true }\n    hashsub1:hashsubdefs_ind? \n    &{ |s| node_cache[:hashsubdefs_ind].delete( index ); @indentationLevels.pop; true }\n    hashsub2:hashsubdefs_ind?   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashsub1.ast ] )\n        r.merge!( hashsub2.ast )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = r[keydef.ast]  unless refdef_tl.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws ':' wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        hashsubdefs_ind.ast\n      end\n    }\n    /\n    indentation '' \n    &{ |s| level = s[0].text_value.length; @lastIndentation=level; true } \n    &{ |s| false }\n    {\n      def ast\n      end\n    }\n    /\n    &{ |s| @indentationLevels << (@lastIndentation-2); true }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( hashsubdefs_ind.ast )\n        r\n      end\n    }\n  end\n\n  rule arraydef_ind\n    indentation bc_0_l:(bc_0*) ws ',' ws '@schema' ws schemaname ws '(' ws schema_fieldlist ws ')' wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_schema_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << schema_fieldlist.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast] = schema_fieldlist.ast\n        res = arraysubdefs_schema_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws ',' ws '@schema' ws '(' ws schema_fieldlist ws ')' wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_schema_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << schema_fieldlist.ast\n        res = arraysubdefs_schema_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws ',' ws '@schema' ws schemaname wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_schema_ind    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        \n        unless ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast]\n          ###orig-ok# raise SyntaxError, \"GDS: undefined schema specifier: \#{schemaname.ast}\"\n          s = \"GDS: undefined schema specifier: \"\n          nt = schemaname\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n      \n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast]\n        res = arraysubdefs_schema_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws ',' ws refdef_tl:refdef? ws valuedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = valuedefs_ind.ast  unless refdef_tl.empty?\n        r = []\n        r2 = valuedefs_ind.ast\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r2 = arraysubdefs_ind.ast\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws ',' wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        arraysubdefs_ind.ast\n      end\n    }\n  end\n\n  rule hashsubdefs_ind\n    ( \n    &{ |s| save = index; i = _nt_indentation; level = i.text_value.length; index = save; ok = (level == (2 + @indentationLevels.last)); ok }\n    hashsubdef_ind '' \n    )*\n    {\n      def ast\n        r = {}\n        elements.each { |e| r.merge!( e.hashsubdef_ind.ast ) }\n        r\n      end\n    }\n  end\n\n  rule hashsubdef_ind\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws keydef ws rd2:refdef? ws ',' ws '@schema' ws schemaname wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        \n        unless ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast]\n          s = \"GDS: undefined schema specifier: \"\n          nt = schemaname\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n      \n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast]\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = arraysubdefs_schema_ind.ast  unless rd2.empty?\n        r.merge!( Hash[ keydef.ast, arraysubdefs_schema_ind.ast ] )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        res = r\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws keydef ws rd2:refdef? ws ',' ws '@schema' ws '(' ws schema_fieldlist ws ')' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << schema_fieldlist.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = arraysubdefs_schema_ind.ast  unless rd2.empty?\n        r.merge!( Hash[ keydef.ast, arraysubdefs_schema_ind.ast ] )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        res = r\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws keydef ws rd2:refdef? ws ',' ws '@schema' ws schemaname ws '(' ws schema_fieldlist ws ')' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << schema_fieldlist.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast] = schema_fieldlist.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = arraysubdefs_schema_ind.ast  unless rd2.empty?\n        r.merge!( Hash[ keydef.ast, arraysubdefs_schema_ind.ast ] )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        res = r\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws keydef ws ',' ws '@schema' ws schemaname wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        \n        unless ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast]\n          s = \"GDS: undefined schema specifier: \"\n          nt = schemaname\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n      \n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast]\n        r.merge!( Hash[ keydef.ast, arraysubdefs_schema_ind.ast ] )\n        res = r\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws keydef ws rd2:refdef? ws ',' ws rd3:refdef? ws valuedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd3.ast] = valuedefs_ind.ast  unless rd3.empty?\n        r.merge!( Hash[ keydef.ast, begin [].concat( valuedefs_ind.ast ).concat( arraysubdefs_ind.ast ) end ] )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = r[keydef.ast]  unless rd2.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws keydef ws rd2:refdef? ws ',' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = arraysubdefs_ind.ast  unless rd2.empty?\n        r.merge!( Hash[ keydef.ast, arraysubdefs_ind.ast ] )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws keydef ws rd2:refdef? wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = hashsubdefs_ind.ast  unless rd2.empty?\n        r.merge!( Hash[ keydef.ast, hashsubdefs_ind.ast ] )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws refdef_tl:refdef? ws keyvaluedefs_ind   \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        r = keyvaluedefs_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = r  unless refdef_tl.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws '@merge' ws refuse_ind  \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        refuse_ind.ast\n      end\n    }\n  end\n\n  rule arraysubdefs_ind\n    ( \n    &{ |s| save = index; i = _nt_indentation; level = i.text_value.length; index = save; ok = (level == (2 + @indentationLevels.last)); ok }\n    arraysubdef_ind ''  \n    )*\n    {\n      def ast\n        r = []\n        elements.each do |e|\n          e1 = e.arraysubdef_ind.ast\n          if e1.is_a?( Array )\n            r.concat e1\n          else\n            r << e1\n          end\n        end\n        r\n      end\n    }\n  end\n\n  rule arraysubdef_ind\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws ': ' ws rd2:refdef? ws keyvaluedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = keyvaluedefs_ind.ast  unless rd2.empty?\n        r.merge!( keyvaluedefs_ind.ast )\n        r.merge!( hashsubdefs_ind.ast )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws refdef_tl:refdef? ws ':' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = hashsubdefs_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = r  unless refdef_tl.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws refdef_tl:refdef? ws ':' ws '@merge' ws refuse_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( refuse_ind.ast )\n        r.merge!( hashsubdefs_ind.ast )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = r  unless refdef_tl.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws ': ' ws keydef ws rd2:refdef? wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; @indentationLevels << (2+level); end; ok }\n    hashsub1:hashsubdefs_ind? \n    &{ |s| node_cache[:hashsubdefs_ind].delete( index ); @indentationLevels.pop; true }\n    hashsub2:hashsubdefs_ind?   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashsub1.ast ] )\n        r.merge!( hashsub2.ast )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = r[keydef.ast]  unless rd2.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws keydef ws rd2:refdef? ws ':' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashsubdefs_ind.ast ] )\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = r[keydef.ast]  unless rd2.empty?\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws refdef_tl:refdef? ws ',' ws '@schema' ws schemaname ws '(' ws schema_fieldlist ws ')' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << schema_fieldlist.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast] = schema_fieldlist.ast\n        r = arraysubdefs_schema_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = r  unless refdef_tl.empty?\n        res = r\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        [ res ]\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws refdef_tl:refdef? ws ',' ws '@schema' ws '(' ws schema_fieldlist ws ')' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << schema_fieldlist.ast\n        r = arraysubdefs_schema_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = r  unless refdef_tl.empty?\n        res = r\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        [ res ]\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws refdef_tl:refdef? ws ',' ws '@schema' ws schemaname wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind     \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        \n        unless ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast]\n          s = \"GDS: undefined schema specifier: \"\n          nt = schemaname\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n      \n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema] << ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schemata][schemaname.ast]\n        r = arraysubdefs_schema_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = r  unless refdef_tl.empty?\n        res = r\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].pop\n        [ res ]\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws rd1:refdef? ws ',' ws rd2:refdef? ws valuedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = valuedefs_ind.ast  unless rd2.empty?\n        r = []\n        r2 = valuedefs_ind.ast\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r2 = arraysubdefs_ind.ast\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = r  unless rd1.empty?\n        [\n        r\n        ]\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws refdef_tl:refdef? ws ',' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = arraysubdefs_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = r  unless refdef_tl.empty?\n        [\n        r\n        ]\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws '@insert' ws refuse_ind  \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        refuse_ind.ast\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws refdef_tl:refdef? ws valuedefs_ind   \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        r = valuedefs_ind.ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][refdef_tl.ast] = r  unless refdef_tl.empty?\n        r\n      end\n    }\n  end\n\n  rule arraysubdefs_schema_ind\n    ( \n    &{ |s| save = index; i = _nt_indentation; level = i.text_value.length; index = save; ok = (level == (2 + @indentationLevels.last)); ok }\n    arraysubdef_schema_ind ''  \n    )*\n    {\n      def ast\n        r = []\n        elements.each do |e|\n          e1 = e.arraysubdef_schema_ind.ast\n          if e1.is_a?( Array )\n            r.concat e1\n          else\n            r << e1\n          end\n        end\n        r\n      end\n    }\n  end\n\n  rule arraysubdef_schema_ind\n    indentation rd1:refdef? ws ': ' ws rd2:refdef? ws schemavaluedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        \n        if schemavaluedefs_ind.ast.length > ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].last.length\n          s = \"GDS: too many values for schema definition: \"\n          nt = schemavaluedefs_ind\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n        result = {}\n        r1 = schemavaluedefs_ind.ast.each_with_index.map do |e,i|\n          (e.is_a?(Hash) && e[:valuedirective]==:@na) ? ({}) : (Hash[ ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:schema].last[i], e ])\n        end.inject({}){ |res,e| res.merge!(e) }\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd1.ast] = result  unless rd1.empty?\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][rd2.ast] = r1      unless rd2.empty?\n        result.merge!( r1 ).merge!( hashsubdefs_ind.ast )\n      \n      end\n    }\n    /\n    arraysubdef_ind ''\n    {\n      def ast\n        arraysubdef_ind.ast\n      end\n    }\n  end\n\n  rule schemavaluedefs_ind\n    schemavaluedef_ind ws '|' ws schemavaluedefs_ind \n    {\n      def ast\n        r = []\n        r << schemavaluedef_ind.ast\n        r2 = schemavaluedefs_ind.ast\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    schemavaluedef_ind '' \n    {\n      def ast\n        r = []\n        r << schemavaluedef_ind.ast\n        r\n      end\n    }\n  end\n\n  rule schemavaluedef_ind\n    value_directive_ind ''\n    {\n      def ast\n        value_directive_ind.ast\n      end\n    }\n    /\n    valuedef_ind ''\n    {\n      def ast\n        valuedef_ind.ast\n      end\n    }\n  end\n\n  rule refdef\n    '&' identifier \n    {\n      def ast\n        identifier.ast\n      end\n    }\n  end\n\n  rule keyvaluedefs_ind\n    keyvaluedef_ind ws '|' ws keyvaluedefs_ind \n    {\n      def ast\n        r = {}\n        r.merge!( keyvaluedef_ind.ast )\n        r.merge!( keyvaluedefs_ind.ast )\n        r\n      end\n    }\n    /\n    keyvaluedef_ind ''\n    {\n      def ast\n        keyvaluedef_ind.ast\n      end\n    }\n  end\n\n  rule keyvaluedef_ind\n    keydef wsc_l:(wsc+) valuedef_ind \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, valuedef_ind.ast ] )\n        r\n      end\n    }\n  end\n\n  rule valuedef_ind\n    variable_val_ind ''\n    {\n      def ast\n        variable_val_ind.ast\n      end\n    }\n    /\n    refuse_ind ''\n    {\n      def ast\n        refuse_ind.ast\n      end\n    }\n    /\n    valuedef_gen_ind ''\n    {\n      def ast\n        valuedef_gen_ind.ast\n      end\n    }\n    /\n    special_value_ind ''\n    {\n      def ast\n        special_value_ind.ast\n      end\n    }\n    /\n    string_no_leading_space ''\n    {\n      def ast\n        string_no_leading_space.ast\n      end\n    }\n  end\n\n  rule keyvaluedef\n    keydef ':' wscommnl2 valuedef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, valuedef.ast ] )\n        r\n      end\n    }\n    /\n    wscommnl2 ':' keydef wscommnl2 '=>' wscommnl2 valuedef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, valuedef.ast ] )\n        r\n      end\n    }\n  end\n\n  rule valuedefs_ind\n    valuedef_ind ws '|' ws valuedefs_ind \n    {\n      def ast\n        r = []\n        r << valuedef_ind.ast\n        r2 = valuedefs_ind.ast\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    valuedef_ind '' \n    {\n      def ast\n        r = []\n        r << valuedef_ind.ast\n        r\n      end\n    }\n  end\n\n  rule valuedef\n    variable_val ''\n    {\n      def ast\n        variable_val.ast\n      end\n    }\n    /\n    valuedef_gen ''\n    {\n      def ast\n        valuedef_gen.ast\n      end\n    }\n    /\n    special_value ''\n    {\n      def ast\n        special_value.ast\n      end\n    }\n  end\n\n  rule valuedef_gen\n    number_float ''\n    {\n      def ast\n        number_float.ast\n      end\n    }\n    /\n    number_int ''\n    {\n      def ast\n        number_int.ast\n      end\n    }\n    /\n    rubysymbol ''\n    {\n      def ast\n        rubysymbol.ast\n      end\n    }\n    /\n    string_with_quotes ''\n    {\n      def ast\n        string_with_quotes.ast\n      end\n    }\n  end\n\n  rule valuedef_gen_ind\n    ruby_eval ''\n    {\n      def ast\n        ruby_eval.ast\n      end\n    }\n    /\n    number_float ''\n    {\n      def ast\n        number_float.ast\n      end\n    }\n    /\n    number_int ''\n    {\n      def ast\n        number_int.ast\n      end\n    }\n    /\n    rubysymbol_ind ''\n    {\n      def ast\n        rubysymbol_ind.ast\n      end\n    }\n    /\n    string_with_quotes ''\n    {\n      def ast\n        string_with_quotes.ast\n      end\n    }\n  end\n\n  rule special_value\n    'nil' \n    {\n      def ast\n        nil\n      end\n    }\n    /\n    'true' \n    {\n      def ast\n        true\n      end\n    }\n    /\n    'false' \n    {\n      def ast\n        false\n      end\n    }\n  end\n\n  rule special_value_ind\n    '!nil' \n    {\n      def ast\n        nil\n      end\n    }\n    /\n    '!true' \n    {\n      def ast\n        true\n      end\n    }\n    /\n    '!false' \n    {\n      def ast\n        false\n      end\n    }\n  end\n\n  rule value_directive_ind\n    '@na' \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ :valuedirective, :@na ] )\n        r\n      end\n    }\n  end\n\n  rule string_with_quotes\n    string_with_doublequotes ''\n    {\n      def ast\n        string_with_doublequotes.ast\n      end\n    }\n    /\n    string_with_singlequotes ''\n    {\n      def ast\n        string_with_singlequotes.ast\n      end\n    }\n  end\n\n  rule string_with_doublequotes\n    '\"' string_double_q '\"'\n    {\n      def ast\n        string_double_q.ast\n      end\n    }\n  end\n\n  rule string_double_q\n    ('\\\\\\\\' / '\\\"' / !'\"' .)* \n    {\n      def ast\n        \n        text_value.gsub(/(\\\\\\\\)|(\\\\n)|(\\\\\")/, '\\\\\\\\'=>'\\\\', \"\\\\n\"=>\"\\n\", '\\\\\"'=>'\"').gsub( /(?<!\\\\)\\$\\(([_a-zA-Z][_a-zA-Z0-9]*)\\)/ ) { |s1| key = s1.match('[_a-zA-Z0-9]+')[0].to_sym\n          unless ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars].key?(key)\n            s = \"GDS: undefined variable in string interpolation: \"\n            nt = self\n            lines = nt.input[0..nt.interval.begin].lines\n            lineOfFailure   = lines.size\n            columnOfFailure = lines.last.size + text_value.index( /(?<!\\\\)\\$\\(([_a-zA-Z][_a-zA-Z0-9]*)\\)/ ) + 2\n            s += \"\#{key}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n            s += \"--->\" + \"\\n\"\n            s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n            s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n            s += \"<---\" + \"\\n\"\n            raise SyntaxError, s\n          end\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars][key].to_s }.gsub(/\\\\\\$/, \"$\" )\n      \n      end\n    }\n  end\n\n  rule string_with_singlequotes\n    '\\'' string_single_q '\\''\n    {\n      def ast\n        string_single_q.ast\n      end\n    }\n  end\n\n  rule string_single_q\n    ('\\\\\\\\'/ '\\\\\\'' / !'\\'' .)* \n    {\n      def ast\n        text_value.gsub(/(\\\\\\\\)|(\\\\n)|(\\\\')/, '\\\\\\\\'=>'\\\\', \"\\\\n\"=>\"\\n\", \"\\\\'\"=>\"'\")\n      end\n    }\n  end\n\n  rule string_no_leading_space\n    (&\"$(\" / ( !\"$\" !';' !'!' !'@' !'&' !'*' !' ' !':' !',' !\"|\" !'#' !'/*')) (!\"\\n\" !\"|\" !'#' !'/*' .)+ \n    {\n      def ast\n        \n        text_value.rstrip.gsub( /(?<!\\\\)\\$\\(([_a-zA-Z][_a-zA-Z0-9]*)\\)/ ) { |s1| key = s1.match('[_a-zA-Z0-9]+')[0].to_sym\n          unless ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars].key?(key)\n            s = \"GDS: undefined variable in string interpolation: \"\n            nt = self\n            lines = nt.input[0..nt.interval.begin].lines\n            lineOfFailure   = lines.size\n            columnOfFailure = lines.last.size + text_value.index( /(?<!\\\\)\\$\\(([_a-zA-Z][_a-zA-Z0-9]*)\\)/ ) + 2\n            s += \"\#{key}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n            s += \"--->\" + \"\\n\"\n            s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n            s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n            s += \"<---\" + \"\\n\"\n            raise SyntaxError, s\n          end\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars][key].to_s }.gsub(/\\\\\\$/, \"$\" )\n      \n      end\n    }\n  end\n\n  rule keydef\n    string_with_quotes '' \n    {\n      def ast\n         string_with_quotes.ast.to_sym \n      end\n    }\n    /\n    identifier ''\n    {\n      def ast\n        identifier.ast\n      end\n    }\n  end\n\n  rule variable_val\n    wscommnl2 '$' varname \n    {\n      def ast\n         \n        unless ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars].key?(varname.ast)\n          s = \"GDS: undefined variable: \"\n          nt = varname\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars][varname.ast]\n      \n      end\n    }\n  end\n\n  rule variable_val_ind\n    '$' varname \n    {\n      def ast\n         \n        unless ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars].key?(varname.ast)\n          s = \"GDS: undefined variable: \"\n          nt = varname\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:gdsglobvars][varname.ast]\n      \n      end\n    }\n  end\n\n  rule refuse_ind\n    '*' identifier \n    {\n      def ast\n        \n        unless ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][identifier.ast]\n          s = \"GDS: undefined reference: \"\n          nt = identifier\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n        ::LDLgeneratedLanguage::Language_gds_03_data.globalvars[:internreferences][identifier.ast]\n      \n      end\n    }\n  end\n\n  rule number_int\n    octal_int ''\n    {\n      def ast\n        octal_int.ast\n      end\n    }\n    /\n    binary_int ''\n    {\n      def ast\n        binary_int.ast\n      end\n    }\n    /\n    hexa_int ''\n    {\n      def ast\n        hexa_int.ast\n      end\n    }\n    /\n    decimal_int ''\n    {\n      def ast\n        decimal_int.ast\n      end\n    }\n  end\n\n  rule octal_int\n    ('-'/'+')? ( '0o' / '0' ) [0-7] ( [0-7] / '_' [0-7] )*   \n    {\n      def ast\n        text_value.to_i(8)\n      end\n    }\n  end\n\n  rule binary_int\n    ('-'/'+')? '0b' [01] ( [01] / '_' [01] )*  \n    {\n      def ast\n        text_value.to_i(2)\n      end\n    }\n  end\n\n  rule hexa_int\n    ('-'/'+')? '0x' [0-9a-fA-F] ( [0-9a-fA-F] / '_' [0-9a-fA-F] )*   \n    {\n      def ast\n        text_value.to_i(16)\n      end\n    }\n  end\n\n  rule decimal_int\n    ('-'/'+')? ('0d')? [1-9] ( [0-9] / '_' [0-9] )*  \n    {\n      def ast\n        text_value.to_i\n      end\n    }\n    /\n    ('0d')? [0]  \n    {\n      def ast\n        text_value.to_i\n      end\n    }\n  end\n\n  rule number_float\n    [+-]? ( [0-9] / '_' [0-9] )* [.] [0-9] ( [0-9] / '_' [0-9] )* (('e'/'E') [+-]? [0-9] ( [0-9] / '_' [0-9] )* )?  \n    {\n      def ast\n        text_value.to_f\n      end\n    }\n  end\n\n  rule rubysymbol\n    wscommnl2 ':' rubysymbolcontent \n    {\n      def ast\n        rubysymbolcontent.ast\n      end\n    }\n  end\n\n  rule rubysymbolcontent\n    wscommnl2 '\"' rubysymbol_in_double_quotes '\"' \n    {\n      def ast\n        rubysymbol_in_double_quotes.ast\n      end\n    }\n    /\n    wscommnl2 '\\'' rubysymbol_in_single_quotes '\\'' \n    {\n      def ast\n        rubysymbol_in_single_quotes.ast\n      end\n    }\n    /\n    ( !'}' !' ' !',' !']' !'#' !'/*' !'*/' !\"\\n\" .)+ \n    {\n      def ast\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule rubysymbol_ind\n    ':' rubysymbolcontent_ind \n    {\n      def ast\n        rubysymbolcontent_ind.ast\n      end\n    }\n  end\n\n  rule rubysymbolcontent_ind\n    '\"' rubysymbol_in_double_quotes '\"' \n    {\n      def ast\n        rubysymbol_in_double_quotes.ast\n      end\n    }\n    /\n    '\\'' rubysymbol_in_single_quotes '\\'' \n    {\n      def ast\n        rubysymbol_in_single_quotes.ast\n      end\n    }\n    /\n    (!' ' !'|' !'#' !'/*' !'*/' !\"\\n\" .)+ \n    {\n      def ast\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule rubysymbol_in_double_quotes\n    ('\\\"' / !'\"' !\"\\n\" .)+ \n    {\n      def ast\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule rubysymbol_in_single_quotes\n    ('\\\\\\'' / !'\\'' !\"\\n\" .)+ \n    {\n      def ast\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule ruby_eval\n    '@r' ws evalexpr \n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.config[:context] ? (eval(evalexpr.ast, ::LDLgeneratedLanguage::Language_gds_03_data.config[:context])) : nil \n      end\n    }\n    /\n    '@env' ws evalexpr \n    {\n      def ast\n        ::LDLgeneratedLanguage::Language_gds_03_data.config[:allow_env] ? (eval(\"ENV['\#{evalexpr.ast.strip}']\")) : nil \n      end\n    }\n  end\n\n  rule evalexpr\n    evalexpr_0_with_nesting ''\n    {\n      def ast\n        evalexpr_0_with_nesting.ast\n      end\n    }\n  end\n\n  rule evalexpr_0_with_nesting\n    &{ |s| @evalexpr_0_with_nestingLevel = 0; true }\n    '(' evalexpr_0_with_nesting_sub ')'\n    {\n      def ast\n        evalexpr_0_with_nesting_sub.ast\n      end\n    }\n  end\n\n  rule evalexpr_0_with_nesting_sub\n    '(' \n    &{ |s| @evalexpr_0_with_nestingLevel += 1; true }\n    evalexpr_0_with_nesting_sub\n    {\n      def ast\n        '(' + evalexpr_0_with_nesting_sub.ast\n      end\n    }\n    /\n    ')' \n    &{ |s| ok = (@evalexpr_0_with_nestingLevel > 0); ok } \n    &{ |s| @evalexpr_0_with_nestingLevel -= 1; true }\n    evalexpr_0_with_nesting_sub\n    {\n      def ast\n        ')' + evalexpr_0_with_nesting_sub.ast\n      end\n    }\n    /\n    ( !\"(\" !\")\" . )+ evalexpr_0_with_nesting_sub\n    {\n      def ast\n        text_value\n      end\n    }\n    /\n    ''\n    {\n      def ast\n        ''\n      end\n    }\n  end\n\n  rule evalexpr_0_with_nesting_onechar\n    ( !\")\" . )\n    {\n      def ast\n        text_value\n      end\n    }\n  end\n\n  rule bc_0\n    &{ |s| @bc_0Level = 0; true }\n    '/*' bc_0_sub '*/'\n    {\n      def ast\n        \"/*\" + bc_0_sub.ast + \"*/\"\n      end\n    }\n  end\n\n  rule bc_0_sub\n    '/*' \n    &{ |s| @bc_0Level += 1; true }\n    bc_0_sub\n    {\n      def ast\n        '/*' + bc_0_sub.ast\n      end\n    }\n    /\n    '*/' \n    &{ |s| ok = (@bc_0Level > 0); ok } \n    &{ |s| @bc_0Level -= 1; true }\n    bc_0_sub\n    {\n      def ast\n        '*/' + bc_0_sub.ast\n      end\n    }\n    /\n    ( !\"/*\" !\"*/\" . )+ bc_0_sub\n    {\n      def ast\n        text_value\n      end\n    }\n    /\n    ''\n    {\n      def ast\n        ''\n      end\n    }\n  end\n\n  rule bc_0_onechar\n    ( !\"*/\" . )\n    {\n      def ast\n        text_value\n      end\n    }\n  end\n\n  rule wsc\n    [ \\t] \n    {\n    }\n    /\n    bc_0 '' \n    {\n    }\n  end\n\n  rule identifier\n    ([a-zA-Z_] [a-zA-Z0-9_]*)\n    {\n      def ast\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule string_no_space\n    [a-zA-Z0-9_/.:]+\n    {\n      def ast\n        text_value\n      end\n    }\n  end\n\n  rule indentation\n    ' '*\n  end\n\n  rule ws\n    wsc*\n  end\n\n  rule icomm\n    '#' \n  end\n\n  rule wscommnl\n    ws ( icomm ( !\"\\n\" . )* )? \"\\n\"\n  end\n\n  rule wscommnl2\n    ( icomm ( !\"\\n\" . )* \"\\n\" / \"\\n\" / wsc )*\n  end\n\nend\n"

  end
end
