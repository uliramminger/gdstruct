# lng_gds.rb

# ATTENTION: this file is generated

module LDLgeneratedLanguage

  class Gds
    require 'treetop'

    class SyntaxError < ::StandardError
    end

    def self.parse( s, config = {} )
      @parserClass ||= begin
        Treetop.load_from_string GrammarDef
        instance_eval( 'Language_gds_03Parser' )
      end
      parser = @parserClass.new

      parseTree = parser.parse( s + "\n" )

      unless parseTree
        lineOfFailure   = parser.failure_line
        columnOfFailure = parser.failure_column

        s = "LANGUAGE_GDS: Error happend, while parsing the definition: line #{lineOfFailure}, column #{columnOfFailure}" + "\n"
        s += parser.failure_reason + "\n"  if parser.failure_reason
        s += "--->" + "\n"
        s += parser.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + "\n"
        s += ' '*((parser.failure_column) -1) + '^' + "\n"
        s += "<---" + "\n"

        raise SyntaxError, s
      end

      context = Struct.new( :config, :globalvars ).new( { allow_env: false, context: nil }.merge( config ), {} )

      parseTree.ast( context )
    end

    GrammarDef = "grammar Language_gds_03\n\n  rule top_r\n    &{ |s| @indentationLevels = []; true }\n    defs_r ''\n    {\n      def ast( context )\n        context.globalvars[:schemata] ||= {}\n        context.globalvars[:gdsglobvars] ||= {}\n        context.globalvars[:internreferences] ||= {}\n        context.globalvars[:schema] ||= []\n        defs_r.ast( context )\n      end\n    }\n  end\n\n  rule defs_r\n    wscommnl_r* predefs_r wscommnl_r* defs2_r \n    {\n      def ast( context )\n        dummy = predefs_r.ast( context )\n        r = defs2_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule predefs_r\n    predef_r* \n    {\n      def ast( context )\n        elements.each { |e| e.ast( context ) }\n      end\n    }\n  end\n\n  rule predef_r\n    wscommnl2_r '@schema' wscommnl2_r schemaname_r wscommnl2_r '(' wscommnl2_r schema_fieldlist_r wscommnl2_r ')'  \n    {\n      def ast( context )\n        context.globalvars[:schemata][schemaname_r.ast( context )] = schema_fieldlist_r.ast( context )\n      end\n    }\n    /\n    wscommnl2_r '$' varname_r wscommnl2_r '=' wscommnl2_r vardef_rvalue_r  \n    {\n      def ast( context )\n        context.globalvars[:gdsglobvars][varname_r.ast( context )] = vardef_rvalue_r.ast( context )\n      end\n    }\n  end\n\n  rule schemaname_r\n    identifier_r '' \n    {\n      def ast( context )\n        r = identifier_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule varname_r\n    identifier_r ''\n    {\n      def ast( context )\n        identifier_r.ast( context )\n      end\n    }\n  end\n\n  rule vardef_rvalue_r\n    valuedef_ind_r ''\n    {\n      def ast( context )\n        valuedef_ind_r.ast( context )\n      end\n    }\n  end\n\n  rule schema_fieldlist_r\n    schemafield_r ws_r ',' ws_r schema_fieldlist_r \n    {\n      def ast( context )\n        r = []\n        r << schemafield_r.ast( context )\n        r2 = schema_fieldlist_r.ast( context )\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    schemafield_r '' \n    {\n      def ast( context )\n        r = []\n        r << schemafield_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule schemafield_r\n    identifier_r '' \n    {\n      def ast( context )\n        r = identifier_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule defs2_r\n    wscommnl2_r ruby_standard_def_r wscommnl2_r\n    {\n      def ast( context )\n        ruby_standard_def_r.ast( context )\n      end\n    }\n    /\n    wscommnl_r* special_indented_def_r wscommnl2_r\n    {\n      def ast( context )\n        special_indented_def_r.ast( context )\n      end\n    }\n  end\n\n  rule ruby_standard_def_r\n    hashdef_r ''\n    {\n      def ast( context )\n        hashdef_r.ast( context )\n      end\n    }\n    /\n    arraydef_r ''\n    {\n      def ast( context )\n        arraydef_r.ast( context )\n      end\n    }\n  end\n\n  rule special_indented_def_r\n    arraydef_ind_r ''\n    {\n      def ast( context )\n        arraydef_ind_r.ast( context )\n      end\n    }\n    /\n    hashdef_ind_r ''\n    {\n      def ast( context )\n        hashdef_ind_r.ast( context )\n      end\n    }\n  end\n\n  rule hashdef_r\n    wscommnl2_r '{' wscommnl2_r hashsubdefs_r wscommnl2_r '}' \n    {\n      def ast( context )\n        r = hashsubdefs_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule arraydef_r\n    wscommnl2_r '[' wscommnl2_r arraysubdefs_r wscommnl2_r ']' \n    {\n      def ast( context )\n        r = arraysubdefs_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule hashsubdefs_r\n    hashsubdef_r wscommnl2_r morehashsubdefs_r wscommnl2_r ','? \n    {\n      def ast( context )\n        r = {}\n        r.merge!( hashsubdef_r.ast( context ) )\n        r.merge!( morehashsubdefs_r.ast( context ) )\n        r\n      end\n    }\n    /\n    ''\n    {\n      def ast( context )\n        {}\n      end\n    }\n  end\n\n  rule morehashsubdefs_r\n    morehashsubdef_r*\n    {\n      def ast( context )\n        r = {}\n        elements.each { |e| r.merge!( e.ast( context ) ) }\n        r\n      end\n    }\n  end\n\n  rule morehashsubdef_r\n    wscommnl2_r ',' wscommnl2_r hashsubdef_r\n    {\n      def ast( context )\n        hashsubdef_r.ast( context )\n      end\n    }\n  end\n\n  rule hashsubdef_r\n    keyvaluedef_r ''\n    {\n      def ast( context )\n        keyvaluedef_r.ast( context )\n      end\n    }\n    /\n    keydef_r ':' wscommnl2_r hashdef_r \n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), hashdef_r.ast( context ) ] )\n        r\n      end\n    }\n    /\n    wscommnl2_r ':' keydef_r wscommnl2_r '=>' wscommnl2_r hashdef_r \n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), hashdef_r.ast( context ) ] )\n        r\n      end\n    }\n    /\n    keydef_r ':' wscommnl2_r arraydef_r \n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), arraydef_r.ast( context ) ] )\n        r\n      end\n    }\n    /\n    wscommnl2_r ':' keydef_r wscommnl2_r '=>' wscommnl2_r arraydef_r \n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), arraydef_r.ast( context ) ] )\n        r\n      end\n    }\n  end\n\n  rule arraysubdefs_r\n    arraysubdef_r wscommnl2_r morearraysubdefs_r wscommnl2_r ','? \n    {\n      def ast( context )\n        r = []\n        r << arraysubdef_r.ast( context )\n        r2 = morearraysubdefs_r.ast( context )\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    '' \n    {\n      def ast( context )\n        r = []\n        r\n      end\n    }\n  end\n\n  rule morearraysubdefs_r\n    morearraysubdef_r* \n    {\n      def ast( context )\n        r = []\n        elements.each do |e|\n          r << e.ast( context )\n        end\n        r\n      end\n    }\n  end\n\n  rule morearraysubdef_r\n    wscommnl2_r ',' wscommnl2_r arraysubdef_r\n    {\n      def ast( context )\n        arraysubdef_r.ast( context )\n      end\n    }\n  end\n\n  rule arraysubdef_r\n    valuedef_r ''\n    {\n      def ast( context )\n        valuedef_r.ast( context )\n      end\n    }\n    /\n    arraydef_r ''\n    {\n      def ast( context )\n        arraydef_r.ast( context )\n      end\n    }\n    /\n    hashdef_r ''\n    {\n      def ast( context )\n        hashdef_r.ast( context )\n      end\n    }\n    /\n    hashsubdef_r ''\n    {\n      def ast( context )\n        hashsubdef_r.ast( context )\n      end\n    }\n  end\n\n  rule hashdef_ind_r\n    indentation_r bc_0_l:(bc_0_r*) ws_r ': ' ws_r refdef_tl:refdef_r? ws_r keyvaluedefs_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    hashsubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = keyvaluedefs_ind_r.ast( context )  unless refdef_tl.empty?\n        r.merge!( keyvaluedefs_ind_r.ast( context ) )\n        r.merge!( hashsubdefs_ind_r.ast( context ) )\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ': ' ws_r keydef_r ws_r refdef_tl:refdef_r? wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; @indentationLevels << (2+level); true }\n    hashsub1_r:hashsubdefs_ind_r? \n    &{ |s| node_cache[:hashsubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    hashsub2_r:hashsubdefs_ind_r?   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), hashsub1_r.ast( context ) ] )\n        r.merge!( hashsub2_r.ast( context ) )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = r[keydef_r.ast( context )]  unless refdef_tl.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ':' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    hashsubdefs_ind_r  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = hashsubdefs_ind_r.ast( context )\n        r\n      end\n    }\n    /\n    indentation_r '' \n    &{ |s| level = s[0].text_value.length; @lastIndentation=level; true } \n    &{ |s| false }\n    {\n      def ast( context )\n      end\n    }\n    /\n    &{ |s| @indentationLevels << (@lastIndentation-2); true }\n    hashsubdefs_ind_r  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        r.merge!( hashsubdefs_ind_r.ast( context ) )\n        r\n      end\n    }\n  end\n\n  rule arraydef_ind_r\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r '@schema' ws_r schemaname_r ws_r '(' ws_r schema_fieldlist_r ws_r ')' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_schema_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:schema] << schema_fieldlist_r.ast( context )\n        context.globalvars[:schemata][schemaname_r.ast( context )] = schema_fieldlist_r.ast( context )\n        r = arraysubdefs_schema_ind_r.ast( context )\n        res = r\n        context.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r '@schema' ws_r '(' ws_r schema_fieldlist_r ws_r ')' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_schema_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:schema] << schema_fieldlist_r.ast( context )\n        r = arraysubdefs_schema_ind_r.ast( context )\n        res = r\n        context.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r '@schema' ws_r schemaname_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_schema_ind_r    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        \n        unless context.globalvars[:schemata][schemaname_r.ast( context )]\n          ###orig-ok# raise SyntaxError, \"GDS: undefined schema specifier: \#{schemaname.ast}\"\n          s = \"GDS: undefined schema specifier: \"\n          nt = schemaname_r\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast( context )}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n      \n        context.globalvars[:schema] << context.globalvars[:schemata][schemaname_r.ast( context )]\n        r = arraysubdefs_schema_ind_r.ast( context )\n        res = r\n        context.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r ':' ws_r rd1_r:refdef_r? ws_r keyvaluedefs_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; @indentationLevels << (2+level); true }\n    hashsubdefs_ind_r \n    &{ |s| node_cache[:arraysubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    arraysubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = keyvaluedefs_ind_r.ast( context )  unless rd1_r.empty?\n        r = begin [].push( ->(;r){ r={};r.merge!( keyvaluedefs_ind_r.ast( context ) );r.merge!( hashsubdefs_ind_r.ast( context ) ); r }.() ).concat( arraysubdefs_ind_r.ast( context ) ) end\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r ': ' ws_r keydef_r ws_r rd2_r:refdef_r? wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; @indentationLevels << (2+level); @indentationLevels << (4+level); true }\n    hashsub1_r:hashsubdefs_ind_r? \n    &{ |s| node_cache[:hashsubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    hashsub2_r:hashsubdefs_ind_r? \n    &{ |s| node_cache[:arraysubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    arraysubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:internreferences][rd2_r.ast( context )] = hashsub1_r.ast( context )  unless rd2_r.empty?\n        r = begin [].push( ->(;r){ r={};r.store( keydef_r.ast( context ), hashsub1_r.ast( context ) );r.merge!( hashsub2_r.ast( context ) ); r }.() ).concat( arraysubdefs_ind_r.ast( context ) ) end\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r ':' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; @indentationLevels << (2+level); true }\n    hashsubdefs_ind_r \n    &{ |s| node_cache[:arraysubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    arraysubdefs_ind_r  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = begin [].push( ->(;r){ r={};r.merge!( hashsubdefs_ind_r.ast( context ) ); r }.() ).concat( arraysubdefs_ind_r.ast( context ) ) end\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r refdef_tl:refdef_r? ws_r valuedefs_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = valuedefs_ind_r.ast( context )  unless refdef_tl.empty?\n        r = []\n        r2 = valuedefs_ind_r.ast( context )\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r2 = arraysubdefs_ind_r.ast( context )\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_ind_r  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = arraysubdefs_ind_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule hashsubdefs_ind_r\n    ( \n    &{ |s| save = index; i = _nt_indentation_r; level = i.text_value.length; index = save; ok = (level == (2 + @indentationLevels.last)); ok }\n    hashsubdef_ind_r '' \n    )*\n    {\n      def ast( context )\n        r = {}\n        elements.each { |e| r.merge!( e.hashsubdef_ind_r.ast( context ) ) }\n        r\n      end\n    }\n  end\n\n  rule hashsubdef_ind_r\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r keydef_r ws_r rd2_r:refdef_r? ws_r ',' ws_r '@schema' ws_r schemaname_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind_r    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        \n        unless context.globalvars[:schemata][schemaname_r.ast( context )]\n          s = \"GDS: undefined schema specifier: \"\n          nt = schemaname_r\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast( context )}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n      \n        context.globalvars[:schema] << context.globalvars[:schemata][schemaname_r.ast( context )]\n        context.globalvars[:internreferences][rd2_r.ast( context )] = arraysubdefs_schema_ind_r.ast( context )  unless rd2_r.empty?\n        r.merge!( Hash[ keydef_r.ast( context ), arraysubdefs_schema_ind_r.ast( context ) ] )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        res = r\n        context.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r keydef_r ws_r rd2_r:refdef_r? ws_r ',' ws_r '@schema' ws_r '(' ws_r schema_fieldlist_r ws_r ')' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        context.globalvars[:schema] << schema_fieldlist_r.ast( context )\n        context.globalvars[:internreferences][rd2_r.ast( context )] = arraysubdefs_schema_ind_r.ast( context )  unless rd2_r.empty?\n        r.merge!( Hash[ keydef_r.ast( context ), arraysubdefs_schema_ind_r.ast( context ) ] )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        res = r\n        context.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r keydef_r ws_r rd2_r:refdef_r? ws_r ',' ws_r '@schema' ws_r schemaname_r ws_r '(' ws_r schema_fieldlist_r ws_r ')' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        context.globalvars[:schema] << schema_fieldlist_r.ast( context )\n        context.globalvars[:schemata][schemaname_r.ast( context )] = schema_fieldlist_r.ast( context )\n        context.globalvars[:internreferences][rd2_r.ast( context )] = arraysubdefs_schema_ind_r.ast( context )  unless rd2_r.empty?\n        r.merge!( Hash[ keydef_r.ast( context ), arraysubdefs_schema_ind_r.ast( context ) ] )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        res = r\n        context.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r keydef_r ws_r ',' ws_r '@schema' ws_r schemaname_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind_r    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        \n        unless context.globalvars[:schemata][schemaname_r.ast( context )]\n          s = \"GDS: undefined schema specifier: \"\n          nt = schemaname_r\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast( context )}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n      \n        context.globalvars[:schema] << context.globalvars[:schemata][schemaname_r.ast( context )]\n        r.merge!( Hash[ keydef_r.ast( context ), arraysubdefs_schema_ind_r.ast( context ) ] )\n        res = r\n        context.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r keydef_r ws_r rd2_r:refdef_r? ws_r ',' ws_r rd3_r:refdef_r? ws_r valuedefs_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        context.globalvars[:internreferences][rd3_r.ast( context )] = valuedefs_ind_r.ast( context )  unless rd3_r.empty?\n        r.merge!( Hash[ keydef_r.ast( context ), begin [].concat( valuedefs_ind_r.ast( context ) ).concat( arraysubdefs_ind_r.ast( context ) ) end ] )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        context.globalvars[:internreferences][rd2_r.ast( context )] = r[keydef_r.ast( context )]  unless rd2_r.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r keydef_r ws_r rd2_r:refdef_r? ws_r ',' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        context.globalvars[:internreferences][rd2_r.ast( context )] = arraysubdefs_ind_r.ast( context )  unless rd2_r.empty?\n        r.merge!( Hash[ keydef_r.ast( context ), arraysubdefs_ind_r.ast( context ) ] )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r keydef_r ws_r rd2_r:refdef_r? wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        context.globalvars[:internreferences][rd2_r.ast( context )] = hashsubdefs_ind_r.ast( context )  unless rd2_r.empty?\n        r.merge!( Hash[ keydef_r.ast( context ), hashsubdefs_ind_r.ast( context ) ] )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r refdef_tl:refdef_r? ws_r keyvaluedefs_ind_r   \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl_r+\n    {\n      def ast( context )\n        r = keyvaluedefs_ind_r.ast( context )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = r  unless refdef_tl.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r '@merge' ws_r refuse_ind_r  \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl_r+\n    {\n      def ast( context )\n        r = refuse_ind_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule arraysubdefs_ind_r\n    ( \n    &{ |s| save = index; i = _nt_indentation_r; level = i.text_value.length; index = save; ok = (level == (2 + @indentationLevels.last)); ok }\n    arraysubdef_ind_r ''  \n    )*\n    {\n      def ast( context )\n        r = []\n        elements.each do |e|\n          e1 = e.arraysubdef_ind_r.ast( context )\n          if e1.is_a?( Array )\n            r.concat e1\n          else\n            r << e1\n          end\n        end\n        r\n      end\n    }\n  end\n\n  rule arraysubdef_ind_r\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r ': ' ws_r rd2_r:refdef_r? ws_r keyvaluedefs_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        context.globalvars[:internreferences][rd2_r.ast( context )] = keyvaluedefs_ind_r.ast( context )  unless rd2_r.empty?\n        r.merge!( keyvaluedefs_ind_r.ast( context ) )\n        r.merge!( hashsubdefs_ind_r.ast( context ) )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r refdef_tl:refdef_r? ws_r ':' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = hashsubdefs_ind_r.ast( context )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = r  unless refdef_tl.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r refdef_tl:refdef_r? ws_r ':' ws_r '@merge' ws_r refuse_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        r.merge!( refuse_ind_r.ast( context ) )\n        r.merge!( hashsubdefs_ind_r.ast( context ) )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = r  unless refdef_tl.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r ': ' ws_r keydef_r ws_r rd2_r:refdef_r? ws_r ',' ws_r rd3_r:refdef_r? ws_r valuedefs_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; @indentationLevels << (2+level); end; ok }\n    arraysubdefs_ind_r \n    &{ |s| node_cache[:hashsubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    hashsub1_r:hashsubdefs_ind_r?   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        context.globalvars[:internreferences][rd3_r.ast( context )] = valuedefs_ind_r.ast( context )  unless rd3_r.empty?\n        r.merge!( Hash[ keydef_r.ast( context ), begin [].concat( valuedefs_ind_r.ast( context ) ).concat( arraysubdefs_ind_r.ast( context ) ) end ] )\n        r.merge!( hashsub1_r.ast( context ) )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        context.globalvars[:internreferences][rd2_r.ast( context )] = r[keydef_r.ast( context )]  unless rd2_r.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r ': ' ws_r keydef_r ws_r rd2_r:refdef_r? ws_r ',' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; @indentationLevels << (2+level); end; ok }\n    arraysubdefs_ind_r \n    &{ |s| node_cache[:hashsubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    hashsub1_r:hashsubdefs_ind_r?   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), arraysubdefs_ind_r.ast( context ) ] )\n        r.merge!( hashsub1_r.ast( context ) )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        context.globalvars[:internreferences][rd2_r.ast( context )] = r[keydef_r.ast( context )]  unless rd2_r.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r ': ' ws_r keydef_r ws_r rd2_r:refdef_r? wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; @indentationLevels << (2+level); end; ok }\n    hashsub1_r:hashsubdefs_ind_r? \n    &{ |s| node_cache[:hashsubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    hashsub2_r:hashsubdefs_ind_r?   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), hashsub1_r.ast( context ) ] )\n        r.merge!( hashsub2_r.ast( context ) )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        context.globalvars[:internreferences][rd2_r.ast( context )] = r[keydef_r.ast( context )]  unless rd2_r.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r keydef_r ws_r rd2_r:refdef_r? ws_r ':' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), hashsubdefs_ind_r.ast( context ) ] )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        context.globalvars[:internreferences][rd2_r.ast( context )] = r[keydef_r.ast( context )]  unless rd2_r.empty?\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r refdef_tl:refdef_r? ws_r ',' ws_r '@schema' ws_r schemaname_r ws_r '(' ws_r schema_fieldlist_r ws_r ')' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind_r    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:schema] << schema_fieldlist_r.ast( context )\n        context.globalvars[:schemata][schemaname_r.ast( context )] = schema_fieldlist_r.ast( context )\n        r = arraysubdefs_schema_ind_r.ast( context )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = r  unless refdef_tl.empty?\n        res = r\n        context.globalvars[:schema].pop\n        [ res ]\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r refdef_tl:refdef_r? ws_r ',' ws_r '@schema' ws_r '(' ws_r schema_fieldlist_r ws_r ')' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind_r    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:schema] << schema_fieldlist_r.ast( context )\n        r = arraysubdefs_schema_ind_r.ast( context )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = r  unless refdef_tl.empty?\n        res = r\n        context.globalvars[:schema].pop\n        [ res ]\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r refdef_tl:refdef_r? ws_r ',' ws_r '@schema' ws_r schemaname_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind_r     \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        \n        unless context.globalvars[:schemata][schemaname_r.ast( context )]\n          s = \"GDS: undefined schema specifier: \"\n          nt = schemaname_r\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast( context )}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n      \n        context.globalvars[:schema] << context.globalvars[:schemata][schemaname_r.ast( context )]\n        r = arraysubdefs_schema_ind_r.ast( context )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = r  unless refdef_tl.empty?\n        res = r\n        context.globalvars[:schema].pop\n        [ res ]\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r ':' ws_r rd1_r:refdef_r? ws_r keyvaluedefs_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; @indentationLevels << (2+level); end; ok }\n    hashsubdefs_ind_r \n    &{ |s| node_cache[:arraysubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    arraysubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:internreferences][rd1_r.ast( context )] = keyvaluedefs_ind_r.ast( context )  unless rd1_r.empty?\n        r = begin [].push( begin [].push( ->(;r){ r={};r.merge!( keyvaluedefs_ind_r.ast( context ) );r.merge!( hashsubdefs_ind_r.ast( context ) ); r }.() ).concat( arraysubdefs_ind_r.ast( context ) ) end ) end\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r ': ' ws_r keydef_r ws_r rd2_r:refdef_r? wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; @indentationLevels << (2+level); @indentationLevels << (4+level); end; ok }\n    hashsub1_r:hashsubdefs_ind_r? \n    &{ |s| node_cache[:hashsubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    hashsub2_r:hashsubdefs_ind_r? \n    &{ |s| node_cache[:arraysubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    arraysubdefs_ind_r   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:internreferences][rd2_r.ast( context )] = hashsub1_r.ast( context )  unless rd2_r.empty?\n        r = begin [].push( begin [].push( ->(;r){ r={};r.store( keydef_r.ast( context ), hashsub1_r.ast( context ) );r.merge!( hashsub2_r.ast( context ) ); r }.() ).concat( arraysubdefs_ind_r.ast( context ) ) end ) end\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r ',' ws_r ':' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; @indentationLevels << (2+level); end; ok }\n    hashsubdefs_ind_r \n    &{ |s| node_cache[:arraysubdefs_ind_r].delete( index ); @indentationLevels.pop; true }\n    arraysubdefs_ind_r  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = begin [].push( begin [].push( ->(;r){ r={};r.merge!( hashsubdefs_ind_r.ast( context ) ); r }.() ).concat( arraysubdefs_ind_r.ast( context ) ) end ) end\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r rd1_r:refdef_r? ws_r ',' ws_r rd2_r:refdef_r? ws_r valuedefs_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind_r    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        context.globalvars[:internreferences][rd2_r.ast( context )] = valuedefs_ind_r.ast( context )  unless rd2_r.empty?\n        r = []\n        r2 = valuedefs_ind_r.ast( context )\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r2 = arraysubdefs_ind_r.ast( context )\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        context.globalvars[:internreferences][rd1_r.ast( context )] = r  unless rd1_r.empty?\n        [\n        r\n        ]\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r refdef_tl:refdef_r? ws_r ',' wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind_r    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        r = arraysubdefs_ind_r.ast( context )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = r  unless refdef_tl.empty?\n        [\n        r\n        ]\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r '@insert' ws_r refuse_ind_r  \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl_r+\n    {\n      def ast( context )\n        r = refuse_ind_r.ast( context )\n        r\n      end\n    }\n    /\n    indentation_r bc_0_l:(bc_0_r*) ws_r refdef_tl:refdef_r? ws_r valuedefs_ind_r   \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl_r+\n    {\n      def ast( context )\n        r = valuedefs_ind_r.ast( context )\n        context.globalvars[:internreferences][refdef_tl.ast( context )] = r  unless refdef_tl.empty?\n        r\n      end\n    }\n  end\n\n  rule arraysubdefs_schema_ind_r\n    ( \n    &{ |s| save = index; i = _nt_indentation_r; level = i.text_value.length; index = save; ok = (level == (2 + @indentationLevels.last)); ok }\n    arraysubdef_schema_ind_r ''  \n    )*\n    {\n      def ast( context )\n        r = []\n        elements.each do |e|\n          e1 = e.arraysubdef_schema_ind_r.ast( context )\n          if e1.is_a?( Array )\n            r.concat e1\n          else\n            r << e1\n          end\n        end\n        r\n      end\n    }\n  end\n\n  rule arraysubdef_schema_ind_r\n    indentation_r rd1_r:refdef_r? ws_r ': ' ws_r rd2_r:refdef_r? ws_r schemavaluedefs_ind_r wscommnl_r+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind_r  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl_r*\n    {\n      def ast( context )\n        \n        if schemavaluedefs_ind_r.ast( context ).length > context.globalvars[:schema].last.length\n          s = \"GDS: too many values for schema definition: \"\n          nt = schemavaluedefs_ind_r\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n        result = {}\n        r1 = schemavaluedefs_ind_r.ast( context ).each_with_index.map do |e,i|\n          (e.is_a?(Hash) && e[:valuedirective]==:@na) ? ({}) : (Hash[ context.globalvars[:schema].last[i], e ])\n        end.inject({}){ |res,e| res.merge!(e) }\n        context.globalvars[:internreferences][rd1_r.ast( context )] = result  unless rd1_r.empty?\n        context.globalvars[:internreferences][rd2_r.ast( context )] = r1      unless rd2_r.empty?\n        result.merge!( r1 ).merge!( hashsubdefs_ind_r.ast( context ) )\n      \n      end\n    }\n    /\n    arraysubdef_ind_r ''\n    {\n      def ast( context )\n        arraysubdef_ind_r.ast( context )\n      end\n    }\n  end\n\n  rule schemavaluedefs_ind_r\n    schemavaluedef_ind_r ws_r '|' ws_r schemavaluedefs_ind_r \n    {\n      def ast( context )\n        r = []\n        r << schemavaluedef_ind_r.ast( context )\n        r2 = schemavaluedefs_ind_r.ast( context )\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    schemavaluedef_ind_r '' \n    {\n      def ast( context )\n        r = []\n        r << schemavaluedef_ind_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule schemavaluedef_ind_r\n    value_directive_ind_r ''\n    {\n      def ast( context )\n        value_directive_ind_r.ast( context )\n      end\n    }\n    /\n    valuedef_ind_r ''\n    {\n      def ast( context )\n        valuedef_ind_r.ast( context )\n      end\n    }\n  end\n\n  rule refdef_r\n    '&' identifier_r \n    {\n      def ast( context )\n        r = identifier_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule keyvaluedefs_ind_r\n    keyvaluedef_ind_r ws_r '|' ws_r keyvaluedefs_ind_r \n    {\n      def ast( context )\n        r = {}\n        r.merge!( keyvaluedef_ind_r.ast( context ) )\n        r.merge!( keyvaluedefs_ind_r.ast( context ) )\n        r\n      end\n    }\n    /\n    keyvaluedef_ind_r ''\n    {\n      def ast( context )\n        keyvaluedef_ind_r.ast( context )\n      end\n    }\n  end\n\n  rule keyvaluedef_ind_r\n    keydef_r wsc_l:(wsc_r+) valuedef_ind_r \n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), valuedef_ind_r.ast( context ) ] )\n        r\n      end\n    }\n  end\n\n  rule valuedef_ind_r\n    variable_val_ind_r ''\n    {\n      def ast( context )\n        variable_val_ind_r.ast( context )\n      end\n    }\n    /\n    refuse_ind_r ''\n    {\n      def ast( context )\n        refuse_ind_r.ast( context )\n      end\n    }\n    /\n    valuedef_gen_ind_r ''\n    {\n      def ast( context )\n        valuedef_gen_ind_r.ast( context )\n      end\n    }\n    /\n    special_value_ind_r ''\n    {\n      def ast( context )\n        special_value_ind_r.ast( context )\n      end\n    }\n    /\n    string_no_leading_space_r ''\n    {\n      def ast( context )\n        string_no_leading_space_r.ast( context )\n      end\n    }\n  end\n\n  rule keyvaluedef_r\n    keydef_r ':' wscommnl2_r valuedef_r \n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), valuedef_r.ast( context ) ] )\n        r\n      end\n    }\n    /\n    wscommnl2_r ':' keydef_r wscommnl2_r '=>' wscommnl2_r valuedef_r \n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ keydef_r.ast( context ), valuedef_r.ast( context ) ] )\n        r\n      end\n    }\n  end\n\n  rule valuedefs_ind_r\n    valuedef_ind_r ws_r '|' ws_r valuedefs_ind_r \n    {\n      def ast( context )\n        r = []\n        r << valuedef_ind_r.ast( context )\n        r2 = valuedefs_ind_r.ast( context )\n        if r2.is_a?(Array); r.concat( r2 ); else r << r2; end\n        r\n      end\n    }\n    /\n    valuedef_ind_r '' \n    {\n      def ast( context )\n        r = []\n        r << valuedef_ind_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule valuedef_r\n    variable_val_r ''\n    {\n      def ast( context )\n        variable_val_r.ast( context )\n      end\n    }\n    /\n    valuedef_gen_r ''\n    {\n      def ast( context )\n        valuedef_gen_r.ast( context )\n      end\n    }\n    /\n    special_value_r ''\n    {\n      def ast( context )\n        special_value_r.ast( context )\n      end\n    }\n  end\n\n  rule valuedef_gen_r\n    number_float_r ''\n    {\n      def ast( context )\n        number_float_r.ast( context )\n      end\n    }\n    /\n    number_int_r ''\n    {\n      def ast( context )\n        number_int_r.ast( context )\n      end\n    }\n    /\n    rubysymbol_r ''\n    {\n      def ast( context )\n        rubysymbol_r.ast( context )\n      end\n    }\n    /\n    string_with_quotes_r ''\n    {\n      def ast( context )\n        string_with_quotes_r.ast( context )\n      end\n    }\n  end\n\n  rule valuedef_gen_ind_r\n    ruby_eval_r ''\n    {\n      def ast( context )\n        ruby_eval_r.ast( context )\n      end\n    }\n    /\n    number_float_r ''\n    {\n      def ast( context )\n        number_float_r.ast( context )\n      end\n    }\n    /\n    number_int_r ''\n    {\n      def ast( context )\n        number_int_r.ast( context )\n      end\n    }\n    /\n    rubysymbol_ind_r ''\n    {\n      def ast( context )\n        rubysymbol_ind_r.ast( context )\n      end\n    }\n    /\n    string_with_quotes_r ''\n    {\n      def ast( context )\n        string_with_quotes_r.ast( context )\n      end\n    }\n  end\n\n  rule special_value_r\n    'nil' \n    {\n      def ast( context )\n        nil\n      end\n    }\n    /\n    'true' \n    {\n      def ast( context )\n        true\n      end\n    }\n    /\n    'false' \n    {\n      def ast( context )\n        false\n      end\n    }\n  end\n\n  rule special_value_ind_r\n    '!nil' \n    {\n      def ast( context )\n        nil\n      end\n    }\n    /\n    '@nil' \n    {\n      def ast( context )\n        nil\n      end\n    }\n    /\n    '!true' \n    {\n      def ast( context )\n        true\n      end\n    }\n    /\n    '@true' \n    {\n      def ast( context )\n        true\n      end\n    }\n    /\n    '!false' \n    {\n      def ast( context )\n        false\n      end\n    }\n    /\n    '@false' \n    {\n      def ast( context )\n        false\n      end\n    }\n  end\n\n  rule value_directive_ind_r\n    '@na' \n    {\n      def ast( context )\n        r = {}\n        r.merge!( Hash[ :valuedirective, :@na ] )\n        r\n      end\n    }\n  end\n\n  rule string_with_quotes_r\n    string_with_doublequotes_r ''\n    {\n      def ast( context )\n        string_with_doublequotes_r.ast( context )\n      end\n    }\n    /\n    string_with_singlequotes_r ''\n    {\n      def ast( context )\n        string_with_singlequotes_r.ast( context )\n      end\n    }\n  end\n\n  rule string_with_doublequotes_r\n    '\"' string_double_q_r '\"'\n    {\n      def ast( context )\n        string_double_q_r.ast( context )\n      end\n    }\n  end\n\n  rule string_double_q_r\n    ('\\\\\\\\' / '\\\"' / !'\"' .)* \n    {\n      def ast( context )\n        \n        text_value.gsub(/(\\\\\\\\)|(\\\\n)|(\\\\\")/, '\\\\\\\\'=>'\\\\', \"\\\\n\"=>\"\\n\", '\\\\\"'=>'\"').gsub( /(?<!\\\\)\\$\\(([_a-zA-Z][_a-zA-Z0-9]*)\\)/ ) { |s1| key = s1.match('[_a-zA-Z0-9]+')[0].to_sym\n          unless context.globalvars[:gdsglobvars].key?(key)\n            s = \"GDS: undefined variable in string interpolation: \"\n            nt = self\n            lines = nt.input[0..nt.interval.begin].lines\n            lineOfFailure   = lines.size\n            columnOfFailure = lines.last.size + text_value.index( /(?<!\\\\)\\$\\(([_a-zA-Z][_a-zA-Z0-9]*)\\)/ ) + 2\n            s += \"\#{key}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n            s += \"--->\" + \"\\n\"\n            s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n            s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n            s += \"<---\" + \"\\n\"\n            raise SyntaxError, s\n          end\n        context.globalvars[:gdsglobvars][key].to_s }.gsub(/\\\\\\$/, \"$\" )\n      \n      end\n    }\n  end\n\n  rule string_with_singlequotes_r\n    '\\'' string_single_q_r '\\''\n    {\n      def ast( context )\n        string_single_q_r.ast( context )\n      end\n    }\n  end\n\n  rule string_single_q_r\n    ('\\\\\\\\' / '\\\\\\'' / !'\\'' .)* \n    {\n      def ast( context )\n        r = text_value\n        r.gsub(/(\\\\\\\\)|(\\\\n)|(\\\\')/, '\\\\\\\\'=>'\\\\', \"\\\\n\"=>\"\\n\", \"\\\\'\"=>\"'\")\n      end\n    }\n  end\n\n  rule string_no_leading_space_r\n    (&\"$(\" / ( !\"$\" !';' !'!' !'@' !'&' !'*' !' ' !':' !',' !\"|\" !'#' !'/*')) (!\"\\n\" !\"|\" !'#' !'/*' .)+ \n    {\n      def ast( context )\n        \n        text_value.rstrip.gsub( /(?<!\\\\)\\$\\(([_a-zA-Z][_a-zA-Z0-9]*)\\)/ ) { |s1| key = s1.match('[_a-zA-Z0-9]+')[0].to_sym\n          unless context.globalvars[:gdsglobvars].key?(key)\n            s = \"GDS: undefined variable in string interpolation: \"\n            nt = self\n            lines = nt.input[0..nt.interval.begin].lines\n            lineOfFailure   = lines.size\n            columnOfFailure = lines.last.size + text_value.index( /(?<!\\\\)\\$\\(([_a-zA-Z][_a-zA-Z0-9]*)\\)/ ) + 2\n            s += \"\#{key}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n            s += \"--->\" + \"\\n\"\n            s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n            s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n            s += \"<---\" + \"\\n\"\n            raise SyntaxError, s\n          end\n        context.globalvars[:gdsglobvars][key].to_s }.gsub(/\\\\\\$/, \"$\" )\n      \n      end\n    }\n  end\n\n  rule keydef_r\n    string_with_quotes_r '' \n    {\n      def ast( context )\n         string_with_quotes_r.ast( context ).to_sym \n      end\n    }\n    /\n    identifier_r ''\n    {\n      def ast( context )\n        identifier_r.ast( context )\n      end\n    }\n  end\n\n  rule variable_val_r\n    wscommnl2_r '$' varname_r \n    {\n      def ast( context )\n         \n        unless context.globalvars[:gdsglobvars].key?(varname_r.ast( context ))\n          s = \"GDS: undefined variable: \"\n          nt = varname_r\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast( context )}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n        context.globalvars[:gdsglobvars][varname_r.ast( context )]\n      \n      end\n    }\n  end\n\n  rule variable_val_ind_r\n    '$' varname_r \n    {\n      def ast( context )\n         \n        unless context.globalvars[:gdsglobvars].key?(varname_r.ast( context ))\n          s = \"GDS: undefined variable: \"\n          nt = varname_r\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast( context )}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n        context.globalvars[:gdsglobvars][varname_r.ast( context )]\n      \n      end\n    }\n  end\n\n  rule refuse_ind_r\n    '*' identifier_r \n    {\n      def ast( context )\n        \n        unless context.globalvars[:internreferences][identifier_r.ast( context )]\n          s = \"GDS: undefined reference: \"\n          nt = identifier_r\n          lines = nt.input[0..nt.interval.begin].lines\n          lineOfFailure   = lines.size\n          columnOfFailure = lines.last.size\n          s += \"\#{nt.ast( context )}, line \#{lineOfFailure}, column \#{columnOfFailure}\" + \"\\n\"\n          s += \"--->\" + \"\\n\"\n          s += nt.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + \"\\n\"\n          s += ' '*((columnOfFailure) -1) + '^' + \"\\n\"\n          s += \"<---\" + \"\\n\"\n          raise SyntaxError, s\n        end\n        context.globalvars[:internreferences][identifier_r.ast( context )]\n      \n      end\n    }\n  end\n\n  rule number_int_r\n    octal_int_r ''\n    {\n      def ast( context )\n        octal_int_r.ast( context )\n      end\n    }\n    /\n    binary_int_r ''\n    {\n      def ast( context )\n        binary_int_r.ast( context )\n      end\n    }\n    /\n    hexa_int_r ''\n    {\n      def ast( context )\n        hexa_int_r.ast( context )\n      end\n    }\n    /\n    decimal_int_r ''\n    {\n      def ast( context )\n        decimal_int_r.ast( context )\n      end\n    }\n  end\n\n  rule octal_int_r\n    ('-'/'+')? ( '0o' / '0' ) [0-7] ( [0-7] / '_' [0-7] )*   \n    {\n      def ast( context )\n        r = text_value\n        r.to_i(8)\n      end\n    }\n  end\n\n  rule binary_int_r\n    ('-'/'+')? '0b' [01] ( [01] / '_' [01] )*  \n    {\n      def ast( context )\n        r = text_value\n        r.to_i(2)\n      end\n    }\n  end\n\n  rule hexa_int_r\n    ('-'/'+')? '0x' [0-9a-fA-F] ( [0-9a-fA-F] / '_' [0-9a-fA-F] )*   \n    {\n      def ast( context )\n        r = text_value\n        r.to_i(16)\n      end\n    }\n  end\n\n  rule decimal_int_r\n    ('-'/'+')? ('0d')? [1-9] ( [0-9] / '_' [0-9] )*  \n    {\n      def ast( context )\n        text_value.to_i\n      end\n    }\n    /\n    ('0d')? [0]  \n    {\n      def ast( context )\n        text_value.to_i\n      end\n    }\n  end\n\n  rule number_float_r\n    [+-]? ( [0-9] / '_' [0-9] )* [.] [0-9] ( [0-9] / '_' [0-9] )* (('e'/'E') [+-]? [0-9] ( [0-9] / '_' [0-9] )* )?  \n    {\n      def ast( context )\n        text_value.to_f\n      end\n    }\n  end\n\n  rule rubysymbol_r\n    wscommnl2_r ':' rubysymbolcontent_r \n    {\n      def ast( context )\n        r = rubysymbolcontent_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule rubysymbolcontent_r\n    wscommnl2_r '\"' rubysymbol_in_double_quotes_r '\"' \n    {\n      def ast( context )\n        r = rubysymbol_in_double_quotes_r.ast( context )\n        r\n      end\n    }\n    /\n    wscommnl2_r '\\'' rubysymbol_in_single_quotes_r '\\'' \n    {\n      def ast( context )\n        r = rubysymbol_in_single_quotes_r.ast( context )\n        r\n      end\n    }\n    /\n    ( !\"'\" !'\"' !'}' !' ' !',' !']' !'#' !'/*' !'*/' !\"\\n\" .)+\n    {\n      def ast( context )\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule rubysymbol_ind_r\n    ':' rubysymbolcontent_ind_r \n    {\n      def ast( context )\n        r = rubysymbolcontent_ind_r.ast( context )\n        r\n      end\n    }\n  end\n\n  rule rubysymbolcontent_ind_r\n    '\"' rubysymbol_in_double_quotes_r '\"' \n    {\n      def ast( context )\n        r = rubysymbol_in_double_quotes_r.ast( context )\n        r\n      end\n    }\n    /\n    '\\'' rubysymbol_in_single_quotes_r '\\'' \n    {\n      def ast( context )\n        r = rubysymbol_in_single_quotes_r.ast( context )\n        r\n      end\n    }\n    /\n    (!\"'\" !'\"' !' ' !'|' !'#' !'/*' !'*/' !\"\\n\" .)+\n    {\n      def ast( context )\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule rubysymbol_in_double_quotes_r\n    ('\\\\\\\\' / '\\\\\"' / !'\"' !\"\\n\" .)* \n    {\n      def ast( context )\n        r = text_value\n        r.gsub(/(\\\\\\\\)|(\\\\\")/, '\\\\\\\\'=>'\\\\', '\\\\\"'=>'\"').to_sym\n      end\n    }\n  end\n\n  rule rubysymbol_in_single_quotes_r\n    ('\\\\\\\\' / '\\\\\\'' / !'\\'' !\"\\n\" .)* \n    {\n      def ast( context )\n        r = text_value\n        r.gsub(/(\\\\\\\\)|(\\\\')/, '\\\\\\\\'=>'\\\\', \"\\\\'\"=>\"'\").to_sym\n      end\n    }\n  end\n\n  rule ruby_eval_r\n    '@r' ws_r evalexpr_r \n    {\n      def ast( context )\n        context.config[:context] ? (eval(evalexpr_r.ast( context ), context.config[:context])) : nil \n      end\n    }\n    /\n    '@env' ws_r evalexpr_r \n    {\n      def ast( context )\n        context.config[:allow_env] ? (eval(\"ENV['\#{evalexpr_r.ast( context ).strip}']\")) : nil \n      end\n    }\n  end\n\n  rule evalexpr_r\n    evalexpr_0_with_nesting_r ''\n    {\n      def ast( context )\n        evalexpr_0_with_nesting_r.ast( context )\n      end\n    }\n  end\n\n  rule evalexpr_0_with_nesting_r\n    &{ |s| @evalexpr_0_with_nestingLevel = 0; true }\n    '(' evalexpr_0_with_nesting_sub_r ')'\n    {\n      def ast( context )\n        evalexpr_0_with_nesting_sub.ast( context )\n      end\n    }\n  end\n\n  rule evalexpr_0_with_nesting_sub_r\n    '(' \n    &{ |s| @evalexpr_0_with_nestingLevel += 1; true }\n    evalexpr_0_with_nesting_sub_r\n    {\n      def ast( context )\n        '(' + evalexpr_0_with_nesting_sub.ast( context )\n      end\n    }\n    /\n    ')' \n    &{ |s| ok = (@evalexpr_0_with_nestingLevel > 0); ok } \n    &{ |s| @evalexpr_0_with_nestingLevel -= 1; true }\n    evalexpr_0_with_nesting_sub_r\n    {\n      def ast( context )\n        ')' + evalexpr_0_with_nesting_sub.ast( context )\n      end\n    }\n    /\n    ( !\"(\" !\")\" . )+ evalexpr_0_with_nesting_sub_r\n    {\n      def ast( context )\n        text_value\n      end\n    }\n    /\n    ''\n    {\n      def ast( context )\n        ''\n      end\n    }\n  end\n\n  rule evalexpr_0_with_nesting_onechar_r\n    ( !\")\" . )\n    {\n      def ast( context )\n        text_value\n      end\n    }\n  end\n\n  rule bc_0_r\n    &{ |s| @bc_0Level = 0; true }\n    '/*' bc_0_sub_r '*/'\n    {\n      def ast( context )\n        \"/*\" + bc_0_sub.ast( context ) + \"*/\"\n      end\n    }\n  end\n\n  rule bc_0_sub_r\n    '/*' \n    &{ |s| @bc_0Level += 1; true }\n    bc_0_sub_r\n    {\n      def ast( context )\n        '/*' + bc_0_sub.ast( context )\n      end\n    }\n    /\n    '*/' \n    &{ |s| ok = (@bc_0Level > 0); ok } \n    &{ |s| @bc_0Level -= 1; true }\n    bc_0_sub_r\n    {\n      def ast( context )\n        '*/' + bc_0_sub.ast( context )\n      end\n    }\n    /\n    ( !\"/*\" !\"*/\" . )+ bc_0_sub_r\n    {\n      def ast( context )\n        text_value\n      end\n    }\n    /\n    ''\n    {\n      def ast( context )\n        ''\n      end\n    }\n  end\n\n  rule bc_0_onechar_r\n    ( !\"*/\" . )\n    {\n      def ast( context )\n        text_value\n      end\n    }\n  end\n\n  rule wsc_r\n    [ \\t] \n    {\n    }\n    /\n    bc_0_r '' \n    {\n    }\n  end\n\n  rule identifier_r\n    ([a-zA-Z_] [a-zA-Z0-9_]*)\n    {\n      def ast( context )\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule identifierstr_r\n    ([a-zA-Z_] [a-zA-Z0-9_]*)\n    {\n      def ast( context )\n        text_value\n      end\n    }\n  end\n\n  rule string_no_space_r\n    [a-zA-Z0-9_/.:]+\n    {\n      def ast( context )\n        text_value\n      end\n    }\n  end\n\n  rule indentation_r\n    ' '*\n  end\n\n  rule ws_r\n    wsc_r*\n  end\n\n  rule icomm_r\n    '#' \n  end\n\n  rule wscommnl_r\n    ws_r ( icomm_r ( !\"\\n\" . )* )? \"\\n\"\n  end\n\n  rule wscommnl2_r\n    ( icomm_r ( !\"\\n\" . )* \"\\n\" / \"\\n\" / wsc_r )*\n  end\n\nend\n"

  end
end
