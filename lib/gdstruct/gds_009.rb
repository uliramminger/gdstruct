#===============================================================================

module LDLgeneratedLanguage

  class Gds_009_data
    def self.config 
      @@config ||= {} 
    end
  end
  
  class Gds
    require 'treetop'
  
    class SyntaxError < ::StandardError
    end

    def self.parse( s, config = {} )
      ::LDLgeneratedLanguage::Gds_009_data.config.replace( { allow_env: false, context: nil }.merge( config ) )

      @parserClass ||= begin
        Treetop.load_from_string GrammarDef
        instance_eval( 'Gds_009Parser' )
      end
      parser = @parserClass.new
      
      parseTree = parser.parse( s + "\n" )
      
      unless parseTree
        lineOfFailure   = parser.failure_line
        columnOfFailure = parser.failure_column
        
        s = "GDS: Error happend, while parsing the definition: line #{lineOfFailure}, column #{columnOfFailure}" + "\n"
        s += parser.failure_reason + "\n"  if parser.failure_reason
        s += "--->" + "\n"
        s += parser.input.lines[((lineOfFailure-1-5)>0 ? (lineOfFailure-1-5) : 0)..(lineOfFailure-1)].join.chomp + "\n"
        s += ' '*((parser.failure_column) -1) + '^' + "\n"
        s += "<---" + "\n"
                
        raise SyntaxError, s
      end
      
      parseTree.ast      
    end

    GrammarDef = "grammar Gds_009\n\n  rule top\n    &{ |s| @indentationLevels = []; true }\n    defs ''\n    {\n      def ast\n        eval 'class ::LDLgeneratedLanguage::Gds_009_data; def self.globalvars; @@globalvars ||= {}; end; end'\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars.clear\n        defs.ast\n      end\n    }\n  end\n\n  rule defs\n    wscommnl* schemadefs ws defs2  \n    {\n      def ast\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schemata] = schemadefs.ast\n        defs2.ast\n      end\n    }\n    /\n    wscommnl* defs2\n    {\n      def ast\n        defs2.ast\n      end\n    }\n  end\n\n  rule schemadefs\n    schemadef+ \n    {\n      def ast\n        r = []\n        elements.each do |e|\n          r << e.ast\n        end\n        r\n      end\n    }\n  end\n\n  rule schemadef\n    '$' schemaname ws '(' ws schema_fieldlist ws ')' wscommnl2 \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ :name, schemaname.ast ] )\n        r.merge!( Hash[ :fields, schema_fieldlist.ast ] )\n        r\n      end\n    }\n  end\n\n  rule schemaname\n    identifier '' \n    {\n      def ast\n        identifier.ast\n      end\n    }\n  end\n\n  rule schema_fieldlist\n    schemafield ws ',' ws schema_fieldlist \n    {\n      def ast\n        r = []\n        r << schemafield.ast\n        r.concat( schema_fieldlist.ast )\n        r\n      end\n    }\n    /\n    schemafield '' \n    {\n      def ast\n        r = []\n        r << schemafield.ast\n        r\n      end\n    }\n  end\n\n  rule schemafield\n    identifier '' \n    {\n      def ast\n        identifier.ast\n      end\n    }\n  end\n\n  rule defs2\n    wscommnl2 ruby_standard_def wscommnl2\n    {\n      def ast\n        ruby_standard_def.ast\n      end\n    }\n    /\n    wscommnl* special_indented_def wscommnl2\n    {\n      def ast\n        special_indented_def.ast\n      end\n    }\n  end\n\n  rule ruby_standard_def\n    hashdef ''\n    {\n      def ast\n        hashdef.ast\n      end\n    }\n    /\n    arraydef ''\n    {\n      def ast\n        arraydef.ast\n      end\n    }\n  end\n\n  rule special_indented_def\n    arraydef_ind ''\n    {\n      def ast\n        arraydef_ind.ast\n      end\n    }\n    /\n    hashdef_ind ''\n    {\n      def ast\n        hashdef_ind.ast\n      end\n    }\n  end\n\n  rule hashdef\n    '{' ws hashsubdefs ws '}' \n    {\n      def ast\n        hashsubdefs.ast\n      end\n    }\n  end\n\n  rule arraydef\n    '[' ws arraysubdefs ws ']' \n    {\n      def ast\n        arraysubdefs.ast\n      end\n    }\n  end\n\n  rule hashsubdefs\n    hashsubdef ws morehashsubdefs \n    {\n      def ast\n        r = {}\n        r.merge!( hashsubdef.ast )\n        r.merge!( morehashsubdefs.ast )\n        r\n      end\n    }\n    /\n    ''\n    {\n      def ast\n        {}\n      end\n    }\n  end\n\n  rule morehashsubdefs\n    morehashsubdef*\n    {\n      def ast\n        r = {}\n        elements.each { |e| r.merge!( e.ast ) }\n        r\n      end\n    }\n  end\n\n  rule morehashsubdef\n    ',' ws hashsubdef\n    {\n      def ast\n        hashsubdef.ast\n      end\n    }\n  end\n\n  rule hashsubdef\n    keyvaluedef ''\n    {\n      def ast\n        keyvaluedef.ast\n      end\n    }\n    /\n    keydef ':' ws hashdef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashdef.ast ] )\n        r\n      end\n    }\n    /\n    ':' keydef ws '=>' ws hashdef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashdef.ast ] )\n        r\n      end\n    }\n    /\n    keydef ':' ws arraydef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, arraydef.ast ] )\n        r\n      end\n    }\n    /\n    ':' keydef ws '=>' ws arraydef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, arraydef.ast ] )\n        r\n      end\n    }\n  end\n\n  rule arraysubdefs\n    arraysubdef ws morearraysubdefs \n    {\n      def ast\n        r = []\n        r << arraysubdef.ast\n        r.concat( morearraysubdefs.ast )\n        r\n      end\n    }\n    /\n    '' \n    {\n      def ast\n        r = []\n        r\n      end\n    }\n  end\n\n  rule morearraysubdefs\n    morearraysubdef* \n    {\n      def ast\n        r = []\n        elements.each do |e|\n          r << e.ast\n        end\n        r\n      end\n    }\n  end\n\n  rule morearraysubdef\n    ',' ws arraysubdef\n    {\n      def ast\n        arraysubdef.ast\n      end\n    }\n  end\n\n  rule arraysubdef\n    valuedef ''\n    {\n      def ast\n        valuedef.ast\n      end\n    }\n    /\n    arraydef ''\n    {\n      def ast\n        arraydef.ast\n      end\n    }\n    /\n    hashdef ''\n    {\n      def ast\n        hashdef.ast\n      end\n    }\n  end\n\n  rule hashdef_ind\n    indentation ': ' ws keyvaluedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( keyvaluedefs_ind.ast )\n        r.merge!( hashsubdefs_ind.ast )\n        r\n      end\n    }\n    /\n    ': ' ws keyvaluedefs_ind ws eof \n    {\n      def ast\n        r = {}\n        r.merge!( keyvaluedefs_ind.ast )\n        r\n      end\n    }\n    /\n    indentation ':' wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        hashsubdefs_ind.ast\n      end\n    }\n    /\n    indentation '' \n    &{ |s| level = s[0].text_value.length; @lastIndentation=level; true } \n    &{ |s| false }\n    {\n      def ast\n      end\n    }\n    /\n    &{ |s| @indentationLevels << (@lastIndentation-2); true }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( hashsubdefs_ind.ast )\n        r\n      end\n    }\n  end\n\n  rule arraydef_ind\n    indentation ',' ws '$' schemaname wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_schema_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema] ||= []\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema] << schemaname.ast\n        res = arraysubdefs_schema_ind.ast\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation ',' ws valuedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = []\n        r.concat( valuedefs_ind.ast )\n        r.concat( arraysubdefs_ind.ast )\n        r\n      end\n    }\n    /\n    indentation ',' wscommnl+ \n    &{ |s| level = s[0].text_value.length; @indentationLevels << level; true }\n    arraysubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        arraysubdefs_ind.ast\n      end\n    }\n  end\n\n  rule hashsubdefs_ind\n    ( \n    &{ |s| save = index; i = _nt_indentation; level = i.text_value.length; index = save; ok = (level == (2 + @indentationLevels.last)); ok }\n    hashsubdef_ind '' \n    )*\n    {\n      def ast\n        r = {}\n        elements.each { |e| r.merge!( e.hashsubdef_ind.ast ) }\n        r\n      end\n    }\n  end\n\n  rule hashsubdefs_ind2\n    hashsubdef_ind+\n    {\n      def ast\n        r = {}\n        elements.each { |e| r.merge!( e.ast ) }\n        r\n      end\n    }\n  end\n\n  rule hashsubdef_ind\n    indentation bc_0_l:(bc_0*) ws keyvaluedefs_ind  \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        keyvaluedefs_ind.ast\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws keydef ws ',' ws '$' schemaname wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema] ||= []\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema] << schemaname.ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, arraysubdefs_schema_ind.ast ] )\n        res = r\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema].pop\n        res\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws keydef ws ',' ws valuedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, begin [].concat( valuedefs_ind.ast ).concat( arraysubdefs_ind.ast ) end ] )\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws keydef ws ',' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, arraysubdefs_ind.ast ] )\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws keydef wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashsubdefs_ind.ast ] )\n        r\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws keydef ws eof  \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        r = {}\n        r1 = {}\n        r.merge!( Hash[ keydef.ast, r1 ] )\n        r\n      end\n    }\n  end\n\n  rule arraysubdefs_ind\n    ( \n    &{ |s| save = index; i = _nt_indentation; level = i.text_value.length; index = save; ok = (level == (2 + @indentationLevels.last)); ok }\n    arraysubdef_ind ''  \n    )*\n    {\n      def ast\n        r = []\n        elements.each do |e|\n          e1 = e.arraysubdef_ind.ast\n          if e1.is_a?( Array )\n            r.concat e1\n          else\n            r << e1\n          end\n        end\n        r\n      end\n    }\n  end\n\n  rule arraysubdef_ind\n    indentation ': ' ws keyvaluedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( keyvaluedefs_ind.ast )\n        r.merge!( hashsubdefs_ind.ast )\n        r\n      end\n    }\n    /\n    indentation ': ' ws keyvaluedefs_ind  \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        keyvaluedefs_ind.ast\n      end\n    }\n    /\n    indentation ':' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        hashsubdefs_ind.ast\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws keydef ws ':' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashsubdefs_ind.ast ] )\n        r\n      end\n    }\n    /\n    indentation ',' ws '$' schemaname wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_schema_ind    \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema] ||= []\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema] << schemaname.ast\n        res = arraysubdefs_schema_ind.ast\n        ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema].pop\n        [ res ]\n      end\n    }\n    /\n    indentation ',' ws valuedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = []\n        r.concat( valuedefs_ind.ast )\n        r.concat( arraysubdefs_ind.ast )\n        [\n        r\n        ]\n      end\n    }\n    /\n    indentation ',' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind   \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        [\n        arraysubdefs_ind.ast\n        ]\n      end\n    }\n    /\n    indentation bc_0_l:(bc_0*) ws valuedefs_ind  \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        valuedefs_ind.ast\n      end\n    }\n  end\n\n  rule arraysubdefs_schema_ind\n    ( \n    &{ |s| save = index; i = _nt_indentation; level = i.text_value.length; index = save; ok = (level == (2 + @indentationLevels.last)); ok }\n    arraysubdef_schema_ind ''  \n    )*\n    {\n      def ast\n        r = []\n        elements.each do |e|\n          r << e.arraysubdef_schema_ind.ast\n        end\n        r\n      end\n    }\n  end\n\n  rule arraysubdef_schema_ind\n    indentation ':' ws schemavaluedefs_ind wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        schemavaluedefs_ind.ast .each_with_index.map do |e,i|\n                                                                 Hash[ ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schemata].find{|s| s[:name] == ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema].last }[:fields][i], e ]\n                                                               end.inject({}){ |res,e1| res.merge!(e1);res }.merge!( hashsubdefs_ind.ast )\n                                                           \n      end\n    }\n    /\n    indentation ':' ws schemavaluedefs_ind  \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        schemavaluedefs_ind.ast .each_with_index.map do |e,i|\n                                                                 Hash[ ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schemata].find{|s| s[:name] == ::LDLgeneratedLanguage::Gds_009_data.globalvars[:schema].last }[:fields][i], e ]\n                                                               end.inject({}){ |res,e1| res.merge!(e1);res }\n                                                           \n      end\n    }\n    /\n    indentation ':' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        hashsubdefs_ind.ast\n      end\n    }\n    /\n    indentation keydef ws ':' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    hashsubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, hashsubdefs_ind.ast ] )\n        r\n      end\n    }\n    /\n    indentation ',' wscommnl+ \n    &{ |s| level = s[0].text_value.length; ok = (@indentationLevels.last + 2 == level); if(ok); @indentationLevels << level; end; ok }\n    arraysubdefs_ind  \n    &{ |s| @indentationLevels.pop; true }\n    wscommnl*\n    {\n      def ast\n        arraysubdefs_ind.ast\n      end\n    }\n    /\n    indentation valuedef_ind \n    &{ |s| level = s[0].text_value.length; (@indentationLevels.last + 2 == level) }\n    wscommnl+\n    {\n      def ast\n        valuedef_ind.ast\n      end\n    }\n  end\n\n  rule schemavaluedefs_ind\n    schemavaluedef_ind ws '|' ws schemavaluedefs_ind \n    {\n      def ast\n        r = []\n        r << schemavaluedef_ind.ast\n        r.concat( schemavaluedefs_ind.ast )\n        r\n      end\n    }\n    /\n    schemavaluedef_ind '' \n    {\n      def ast\n        r = []\n        r << schemavaluedef_ind.ast\n        r\n      end\n    }\n  end\n\n  rule schemavaluedef_ind\n    valuedef_ind '' \n    {\n      def ast\n        valuedef_ind.ast\n      end\n    }\n  end\n\n  rule keyvaluedefs_ind\n    keyvaluedef_ind ws '|' ws keyvaluedefs_ind \n    {\n      def ast\n        r = {}\n        r.merge!( keyvaluedef_ind.ast )\n        r.merge!( keyvaluedefs_ind.ast )\n        r\n      end\n    }\n    /\n    keyvaluedef_ind ''\n    {\n      def ast\n        keyvaluedef_ind.ast\n      end\n    }\n  end\n\n  rule keyvaluedef_ind\n    keydef ws valuedef_ind \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, valuedef_ind.ast ] )\n        r\n      end\n    }\n  end\n\n  rule valuedef_ind\n    valuedef_gen ''\n    {\n      def ast\n        valuedef_gen.ast\n      end\n    }\n    /\n    special_value_ind ''\n    {\n      def ast\n        special_value_ind.ast\n      end\n    }\n    /\n    string_no_leading_space ''\n    {\n      def ast\n        string_no_leading_space.ast\n      end\n    }\n  end\n\n  rule keyvaluedef\n    keydef ':' ws valuedef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, valuedef.ast ] )\n        r\n      end\n    }\n    /\n    ':' keydef ws '=>' ws valuedef \n    {\n      def ast\n        r = {}\n        r.merge!( Hash[ keydef.ast, valuedef.ast ] )\n        r\n      end\n    }\n  end\n\n  rule valuedefs_ind\n    valuedef_ind ws '|' ws valuedefs_ind \n    {\n      def ast\n        r = []\n        r << valuedef_ind.ast\n        r.concat( valuedefs_ind.ast )\n        r\n      end\n    }\n    /\n    valuedef_ind '' \n    {\n      def ast\n        r = []\n        r << valuedef_ind.ast\n        r\n      end\n    }\n  end\n\n  rule valuedef\n    valuedef_gen ''\n    {\n      def ast\n        valuedef_gen.ast\n      end\n    }\n    /\n    special_value ''\n    {\n      def ast\n        special_value.ast\n      end\n    }\n  end\n\n  rule valuedef_gen\n    ruby_eval ''\n    {\n      def ast\n        ruby_eval.ast\n      end\n    }\n    /\n    number_float ''\n    {\n      def ast\n        number_float.ast\n      end\n    }\n    /\n    number_int ''\n    {\n      def ast\n        number_int.ast\n      end\n    }\n    /\n    rubysymbol ''\n    {\n      def ast\n        rubysymbol.ast\n      end\n    }\n    /\n    string_with_quotes ''\n    {\n      def ast\n        string_with_quotes.ast\n      end\n    }\n  end\n\n  rule special_value\n    'nil' \n    {\n      def ast\n        nil\n      end\n    }\n    /\n    'true' \n    {\n      def ast\n        true\n      end\n    }\n    /\n    'false' \n    {\n      def ast\n        false\n      end\n    }\n  end\n\n  rule special_value_ind\n    '!nil' \n    {\n      def ast\n        nil\n      end\n    }\n    /\n    '!true' \n    {\n      def ast\n        true\n      end\n    }\n    /\n    '!false' \n    {\n      def ast\n        false\n      end\n    }\n  end\n\n  rule string_with_quotes\n    string_with_doublequotes ''\n    {\n      def ast\n        string_with_doublequotes.ast\n      end\n    }\n    /\n    string_with_singlequotes ''\n    {\n      def ast\n        string_with_singlequotes.ast\n      end\n    }\n  end\n\n  rule string_with_doublequotes\n    '\"' string_double_q '\"'\n    {\n      def ast\n        string_double_q.ast\n      end\n    }\n  end\n\n  rule string_double_q\n    ('\\\"' / !'\"' .)*\n    {\n      def ast\n        text_value\n      end\n    }\n  end\n\n  rule string_with_singlequotes\n    '\\'' string_single_q '\\''\n    {\n      def ast\n        string_single_q.ast\n      end\n    }\n  end\n\n  rule string_single_q\n    ('\\\\\\'' / !'\\'' .)*\n    {\n      def ast\n        text_value\n      end\n    }\n  end\n\n  rule string_no_leading_space\n    !' ' !',' !\"|\" !'#' !'/*' (!\"\\n\" !\"|\" !'#' !'/*' .)+ \n    {\n      def ast\n        text_value.rstrip\n      end\n    }\n  end\n\n  rule keydef\n    string_with_quotes '' \n    {\n      def ast\n         string_with_quotes.ast.to_sym \n      end\n    }\n    /\n    identifier ''\n    {\n      def ast\n        identifier.ast\n      end\n    }\n  end\n\n  rule number_int\n    octal_int ''\n    {\n      def ast\n        octal_int.ast\n      end\n    }\n    /\n    binary_int ''\n    {\n      def ast\n        binary_int.ast\n      end\n    }\n    /\n    hexa_int ''\n    {\n      def ast\n        hexa_int.ast\n      end\n    }\n    /\n    decimal_int ''\n    {\n      def ast\n        decimal_int.ast\n      end\n    }\n  end\n\n  rule octal_int\n    ('-'/'+')? ( '0o' / '0' ) [0-7] ( [0-7] / '_' [0-7] )*   \n    {\n      def ast\n        text_value.to_i(8)\n      end\n    }\n  end\n\n  rule binary_int\n    ('-'/'+')? '0b' [01] ( [01] / '_' [01] )*  \n    {\n      def ast\n        text_value.to_i(2)\n      end\n    }\n  end\n\n  rule hexa_int\n    ('-'/'+')? '0x' [0-9a-fA-F] ( [0-9a-fA-F] / '_' [0-9a-fA-F] )*   \n    {\n      def ast\n        text_value.to_i(16)\n      end\n    }\n  end\n\n  rule decimal_int\n    ('-'/'+')? ('0d')? [1-9] ( [0-9] / '_' [0-9] )*  \n    {\n      def ast\n        text_value.to_i\n      end\n    }\n    /\n    ('0d')? [0]  \n    {\n      def ast\n        text_value.to_i\n      end\n    }\n  end\n\n  rule number_float\n    [+-]? ( [0-9] / '_' [0-9] )* [.] [0-9] ( [0-9] / '_' [0-9] )* (('e'/'E') [+-]? [0-9] ( [0-9] / '_' [0-9] )* )?  \n    {\n      def ast\n        text_value.to_f\n      end\n    }\n  end\n\n  rule rubysymbol\n    ':' rubysymbolcontent \n    {\n      def ast\n        rubysymbolcontent.ast\n      end\n    }\n  end\n\n  rule rubysymbolcontent\n    '\"' rubysymbol_in_double_quotes '\"' \n    {\n      def ast\n        rubysymbol_in_double_quotes.ast\n      end\n    }\n    /\n    '\\'' rubysymbol_in_single_quotes '\\'' \n    {\n      def ast\n        rubysymbol_in_single_quotes.ast\n      end\n    }\n    /\n    (!' ' !\"|\" !'#' !'/*' !'*/' !\"\\n\" .)+ \n    {\n      def ast\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule rubysymbol_in_double_quotes\n    ('\\\"' / !'\"' !\"\\n\" .)+ \n    {\n      def ast\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule rubysymbol_in_single_quotes\n    ('\\\\\\'' / !'\\'' !\"\\n\" .)+ \n    {\n      def ast\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule ruby_eval\n    '@r' ws evalexpr \n    {\n      def ast\n        ::LDLgeneratedLanguage::Gds_009_data.config[:context] ? (eval(evalexpr.ast, ::LDLgeneratedLanguage::Gds_009_data.config[:context])) : \"\" \n      end\n    }\n    /\n    '@env' ws evalexpr \n    {\n      def ast\n        ::LDLgeneratedLanguage::Gds_009_data.config[:allow_env] ? (eval(\"ENV['\#{evalexpr.ast}']\")) : \"\" \n      end\n    }\n  end\n\n  rule evalexpr\n    evalexpr_0_with_nesting ''\n    {\n      def ast\n        evalexpr_0_with_nesting.ast\n      end\n    }\n  end\n\n  rule evalexpr_0_with_nesting\n    &{ |s| @evalexpr_0_with_nestingLevel = 0; true }\n    '(' evalexpr_0_with_nesting_sub ')'\n    {\n      def ast\n        evalexpr_0_with_nesting_sub.ast\n      end\n    }\n  end\n\n  rule evalexpr_0_with_nesting_sub\n    '(' \n    &{ |s| @evalexpr_0_with_nestingLevel += 1; true }\n    evalexpr_0_with_nesting_sub\n    {\n      def ast\n        '(' + evalexpr_0_with_nesting_sub.ast\n      end\n    }\n    /\n    ')' \n    &{ |s| ok = (@evalexpr_0_with_nestingLevel > 0); ok } \n    &{ |s| @evalexpr_0_with_nestingLevel -= 1; true }\n    evalexpr_0_with_nesting_sub\n    {\n      def ast\n        ')' + evalexpr_0_with_nesting_sub.ast\n      end\n    }\n    /\n    ( !\"(\" !\")\" . )+ evalexpr_0_with_nesting_sub\n    {\n      def ast\n        text_value\n      end\n    }\n    /\n    ''\n    {\n      def ast\n        ''\n      end\n    }\n  end\n\n  rule evalexpr_0_with_nesting_onechar\n    ( !\")\" . )\n    {\n      def ast\n        text_value\n      end\n    }\n  end\n\n  rule eof\n    (!.) \n    {\n      def ast\n        text_value\n      end\n    }\n  end\n\n  rule bc_0\n    &{ |s| @bc_0Level = 0; true }\n    '/*' bc_0_sub '*/'\n    {\n      def ast\n        \"/*\" + bc_0_sub.ast + \"*/\"\n      end\n    }\n  end\n\n  rule bc_0_sub\n    '/*' \n    &{ |s| @bc_0Level += 1; true }\n    bc_0_sub\n    {\n      def ast\n        '/*' + bc_0_sub.ast\n      end\n    }\n    /\n    '*/' \n    &{ |s| ok = (@bc_0Level > 0); ok } \n    &{ |s| @bc_0Level -= 1; true }\n    bc_0_sub\n    {\n      def ast\n        '*/' + bc_0_sub.ast\n      end\n    }\n    /\n    ( !\"/*\" !\"*/\" . )+ bc_0_sub\n    {\n      def ast\n        text_value\n      end\n    }\n    /\n    ''\n    {\n      def ast\n        ''\n      end\n    }\n  end\n\n  rule bc_0_onechar\n    ( !\"*/\" . )\n    {\n      def ast\n        text_value\n      end\n    }\n  end\n\n  rule wsc\n    [ \\t] \n    {\n    }\n    /\n    bc_0 '' \n    {\n    }\n  end\n\n  rule identifier\n    ([a-zA-Z_] [a-zA-Z0-9_]*)\n    {\n      def ast\n        text_value.to_sym\n      end\n    }\n  end\n\n  rule string_no_space\n    [a-zA-Z0-9_/.:]+\n    {\n      def ast\n        text_value\n      end\n    }\n  end\n\n  rule indentation\n    ' '*\n  end\n\n  rule ws\n    wsc*\n  end\n\n  rule icomm\n    '#' \n  end\n\n  rule wscommnl\n    ws ( icomm ( !\"\\n\" . )* )? \"\\n\"\n  end\n\n  rule wscommnl2\n    ( icomm ( !\"\\n\" . )* \"\\n\" / \"\\n\" / wsc )*\n  end\n\nend\n"
    
  end
end

#===============================================================================

